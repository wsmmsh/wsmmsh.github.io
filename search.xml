<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Centos安装YouCompleteMe</title>
    <url>/2016/02/02/Centos%E5%AE%89%E8%A3%85YouCompleteMe/</url>
    <content><![CDATA[<p>&amp;emsp;&amp;emsp;折腾了一天，总算把YCM装上了，在这里进行一下总结。安装分为快速安装和完整安装，官方推荐完整安装，但大家可以先试一下快速安装，如果不成功再进行完整安装。需要注意的是YouCompleteMe要求Vim版本大于等于7.3，在进行安装前大家需要确定这点。</p>
<span id="more"></span>
<h2 id="安装YouCompleteMe"><a href="#安装YouCompleteMe" class="headerlink" title="安装YouCompleteMe"></a>安装YouCompleteMe</h2><p>&amp;emsp;&amp;emsp;首先确定YCM的安装方式，分为两种：使用Vundle和使用源代码安装,注意此步仅仅相当于安装了一个空壳，并不能使用YCM，还需要后续步骤。</p>
<h4 id="1-使用Vundle安装"><a href="#1-使用Vundle安装" class="headerlink" title="(1)使用Vundle安装"></a>(1)使用Vundle安装</h4><p>&amp;emsp;&amp;emsp;Vundle是Vim的一款管理插件的插件，安装详细请参照<a href="https://github.com/VundleVim/Vundle.vim">Vundle官方网站</a>。注意把官网下方的配置文件放入你自己的.vimrc里，可以把不需要的插件去除。<br>在你的vimrc中添加<code>Plugin &#39;Valloric/YouCompleteMe&#39;</code>，然后执行:PluginInstall。<br>注：使用Vundle更新YCM的时候可能需要重新编译，引用来自官方的提示：</p>
<blockquote>
<p>YCM is a plugin with a compiled component. If you update YCM using Vundle and the ycm_support_libs library APIs have changed (happens rarely), YCM will notify you to recompile it. You should then rerun the install process.</p>
</blockquote>
<h4 id="2-使用源码安装"><a href="#2-使用源码安装" class="headerlink" title="(2)使用源码安装"></a>(2)使用源码安装</h4><pre><code>#下载YouCompleteMe源码
git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/YouCompleteMe
cd YouCompleteMe/ 
#获取YCM的依赖包  
git submodule update --init --recursive
#然后在在vimrc文件中加入
Bundle &#39;Valloric/YouCompleteMe&#39;  
</code></pre>
<h2 id="快速安装"><a href="#快速安装" class="headerlink" title="快速安装"></a>快速安装</h2><p>此处给出支持C-family的命令，其他的选项见参考文档。</p>
<pre><code>cd ~/.vim/bundle/YouCompleteMe  
./install.py --clang-completer
</code></pre>
<p>之后会看到提示安装成功。<br>参考：<a href="https://github.com/Valloric/YouCompleteMe#fedora-linux-x64-installation">Fedora Linux x64 Installation</a></p>
<h2 id="完整安装"><a href="#完整安装" class="headerlink" title="完整安装"></a>完整安装</h2><h3 id="1、安装svn、cmake"><a href="#1、安装svn、cmake" class="headerlink" title="1、安装svn、cmake"></a>1、安装svn、cmake</h3><p>&amp;emsp;&amp;emsp;<code>sudo yum install svn</code><br>因为centos直接使用yum安装的版本号为2.8.11，而llvm源码编译安装不再支持make，需要的cmake要求最低为2.8.12，所以需要源码安装cmake。<br><code>CMake 2.8.12.2 or higher is required.  You are running version 2.8.11</code></p>
<ul>
<li><p>(1)下载最新源码<br> <a href="https://cmake.org/download/">https://cmake.org/download/</a></p>
</li>
<li><p>进入文件下载目录<br> <code>tar -xzvf cmake-3.4.3.tar.gz</code></p>
</li>
<li><p>(2)进入到cmake文件夹中执行引导命令(此时会检查gcc ,gcc-c++是否安装，如果没有请先安装)  </p>
<pre><code> cd cmake-3.4.3
 yum install gcc  
 yum install gcc-c++
 ./bootstrap  
</code></pre>
</li>
<li><p>(3)安装</p>
<pre><code> make
 make install
</code></pre>
</li>
<li><p>(4)添加环境变量，使其永久有效：<br> <code>vim /etc/profile</code><br>在文件末尾追加以下两行代码：  </p>
<pre><code> PATH=/usr/local/cmake/bin:$PATH
 export PATH
</code></pre>
</li>
</ul>
<p>然后执行以下操作：</p>
<pre><code>    source /etc/profile   //使修改生效 
    echo $PATH   //查看PATH值
</code></pre>
<p>验证cmake是否安装成功：</p>
<pre><code>    [root@localhost cmake-3.4.3]# cmake -version
    cmake version 3.4.3
    CMake suite maintained and supported by Kitware(kitware.com/cmake).  
</code></pre>
<p>参考：<a href="http://llvm.org/docs/GettingStarted.html">Getting Started with the LLVM System</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="http://llvm.org/docs/CMake.html">Building LLVM with CMake</a></p>
<h3 id="2、新建目录，编译安装llvm-clang"><a href="#2、新建目录，编译安装llvm-clang" class="headerlink" title="2、新建目录，编译安装llvm-clang"></a>2、新建目录，编译安装llvm-clang</h3><pre><code>#Checkout LLVM:
mkdir ~/llvm-clang   
cd ~/llvm-clang
svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm
#Checkout Clang:
cd llvm/tools
svn co http://llvm.org/svn/llvm-project/cfe/trunk clang
#Checkout extra Clang Tools: 
cd /clang/tools
svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra
#Checkout Compiler-RT:
cd ~/llvm-clang/llvm/projects
svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk     compiler-rt
#Checkout Libomp (required for OpenMP support):
svn co http://llvm.org/svn/llvm-project/openmp/trunk openmp
#cd where you want to build llvm
cd ~/llvm-clang
mkdir llvm-build(in-tree build is not supported)
cd llvm-build
cmake -G &quot;Unix Makefiles&quot; ../llvm
make
</code></pre>
<p>参考：<a href="http://clang.llvm.org/get_started.html">Getting Started: Building and Running Clang</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="http://llvm.org/docs/GettingStarted.html#getting-started-quickly-a-summary">Getting Started with the LLVM System</a></p>
<h3 id="3、安装Python"><a href="#3、安装Python" class="headerlink" title="3、安装Python"></a>3、安装Python</h3><p>如果系统没有装有python及其有关库，则需安装：</p>
<pre><code>#安装python
`sudo yum install python`
#安装python所需要的库  
`sudo yum install python-devel`
</code></pre>
<h3 id="4、编译YCM需要的ycm-support-libs库"><a href="#4、编译YCM需要的ycm-support-libs库" class="headerlink" title="4、编译YCM需要的ycm_support_libs库"></a>4、编译YCM需要的ycm_support_libs库</h3><p>创建一个文件夹来存放编译文件</p>
<pre><code>cd ~  
mkdir ycm_build  
cd ycm_build  
</code></pre>
<p>下一步生成makefile，这一步很重要，有点复杂。</p>
<ol>
<li>如果不需要C-falmily的语义支持：在ycm_build目录下执行：<br><code>cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code> </li>
<li>如果需要C-falmily的语义支持，分三种情况：<br>(1)假如你从llvm的官网下载了LLVM+Clang，然后解压到：<del>&#x2F;ycm_temp&#x2F;llvm_root_dir （该目录下有 bin, lib, include 等文件夹），然后执行：<br>&#96;cmake -G “Unix Makefiles” -DPATH_TO_LLVM_ROOT&#x3D;</del>&#x2F;ycm_temp&#x2F;llvm_root_dir ~&#x2F;.vim&#x2F;bundle&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd&#x2F;cpp<code> (2)如果想用系统的libclang：</code>cmake -G “Unix Makefiles” -DUSE_SYSTEM_LIBCLANG&#x3D;ON ~&#x2F;.vim&#x2F;bundle&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd&#x2F;cpp<code>(3)如果想用自己编译的libclang：</code>cmake -G “Unix Makefiles” -DEXTERNAL_LIBCLANG_PATH&#x3D;&#x2F;path&#x2F;to&#x2F;libclang.so ~&#x2F;.vim&#x2F;bundle&#x2F;YouCompleteMe&#x2F;third_party&#x2F;ycmd&#x2F;cpp<code>   其中/path/to/libclang.so这部分填入你自己的路径。 然后执行</code>make ycm_support_libs&#96;，就完成了整个的安装过程。</li>
</ol>
<h2 id="YouCompleteMe配置"><a href="#YouCompleteMe配置" class="headerlink" title="YouCompleteMe配置:"></a>YouCompleteMe配置:</h2><pre><code>&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
&quot; =&gt; YouCompleteMe  代码自动补全
&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;
Bundle &#39;Valloric/YouCompleteMe&#39;
&quot; youcompleteme  默认tab  s-tab 和自动补全冲突
&quot; let g:ycm_key_list_select_completion=[&#39;&lt;c-n&gt;&#39;]
&quot; let g:ycm_key_list_select_completion = [&#39;&lt;Down&gt;&#39;]
&quot; let g:ycm_key_list_previous_completion=[&#39;&lt;c-p&gt;&#39;]
&quot; let g:ycm_key_list_previous_completion = [&#39;&lt;Up&gt;&#39;]
let g:ycm_confirm_extra_conf=0      &quot; 关闭加载.ycm_extra_conf.py提示
let g:ycm_complete_in_comments = 1  &quot;在注释输入中也能补全
let g:ycm_complete_in_strings = 1   &quot;在字符串输入中也能补全
let g:ycm_collect_identifiers_from_tags_files=1                 &quot; 开启 YCM 基于标签引擎
let g:ycm_collect_identifiers_from_comments_and_strings = 1   &quot;注释和字符串中的文字也会被收入补全
let g:ycm_seed_identifiers_with_syntax=1   &quot;语言关键字补全, 不过python关键字都很短，所以，需要的自己打开
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_min_num_of_chars_for_completion=2                     &quot; 从第2个键入字符就开始罗列匹配项
&quot; 引入，可以补全系统，以及python的第三方包 针对新老版本YCM做了兼容
&quot; old version
if !empty(glob(&quot;~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py&quot;))
    let g:ycm_global_ycm_extra_conf = &quot;~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py&quot;
endif
&quot; new version
if !empty(glob(&quot;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&quot;))
    let g:ycm_global_ycm_extra_conf = &quot;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&quot;
endif

&quot;mapping
nmap &lt;leader&gt;gd :YcmDiags&lt;CR&gt;
nnoremap &lt;leader&gt;gl :YcmCompleter GoToDeclaration&lt;CR&gt;           &quot; 跳转到申明处
nnoremap &lt;leader&gt;gf :YcmCompleter GoToDefinition&lt;CR&gt;            &quot; 跳转到定义处
nnoremap &lt;leader&gt;gg :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;

&quot; 直接触发自动补全
let g:ycm_key_invoke_completion = &#39;&lt;C-Space&gt;&#39;
&quot; 黑名单,不启用
let g:ycm_filetype_blacklist = &#123;
      \ &#39;tagbar&#39; : 1,
      \ &#39;gitcommit&#39; : 1,
      \&#125;  
</code></pre>
<p>参考：<a href="http://www.cnblogs.com/xiehongfeng100/p/4651972.html#autoid-2-7-0">YouCompleteMe配置</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="http://blog.csdn.net/leaf5022/article/details/21290509#comments">Vim智能补全插件YouCompleteMe安装</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>ycm</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML网络协议</title>
    <url>/2016/03/29/HTML%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>本文主要简单的论述下计算机网络的大概结构，并重点讲解下自己对HTTP协议的理解。所有的因特网标准都是以<a href="https://www.ietf.org/rfc.html">RFC(Request For Comments)</a>的形式在因特网上发表的,任何人都可以用电子邮件随时发表对某个文档的意见或建议。</p>
<span id="more"></span>

<h2 id="计算机网络体系"><a href="#计算机网络体系" class="headerlink" title="计算机网络体系"></a>计算机网络体系</h2><p>OSI的七层协议概念清楚，理论完整，但它复杂又不实用，在实际中我们广泛应用的是TCP&#x2F;IP四层体系结构，但我们在学习计算机网络原理时，常采用五层协议的体系结构。五层协议是指<strong>应用层、运输层、网络层、数据链路层、物理层</strong>。  </p>
<ol>
<li><strong>应用层</strong>直接为用户的应用进程(正在运行的程序)提供服务，该层协议有：HTTP、SMTP(电子邮件)、FTP等。  </li>
<li><strong>运输层</strong>主要负责为两个主机进程之间的通信提供服务，主要使用TCP(传输控制协议)、UDP(用户数据报协议)这两种协议。TCP是面向连接的、可靠的、有序的、速度慢的协议，常应用于传输大量数据的场合；UDP是无连接的、不可靠的、无序的、速度快的协议，提供尽最大努力交付，常应用于传输少量数据的场合。基于TCP的协议有：HTTP(80)&#x2F;HTTPS(443)，Telnet(23)，FTP(21)，SMTP(25)。基于UDP的协议有：DHCP(67)，DNS(53)。  </li>
<li><strong>网络层</strong>负责为分组交换网上的不同主机提供通信服务，并且要选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。在TCP&#x2F;IP体系中，网络层使用IP协议。该层的协议有地址解析协议ARP、逆地址解析协议RARP、网际控制报文协议ICMP、虚拟专用网VPN、网络地址转换NAT等。  </li>
<li><strong>数据链路层</strong>负责在相邻两个节点之间传送数据时，将网络层交下来的IP数据报组装成帧(每一帧包括数据和必要的控制信息)，在节点间的链路上透明地传送帧中的数据。  </li>
<li><strong>物理层</strong>上传送数据的单位是比特，它的任务就是透明的传送比特流。</li>
</ol>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>在这里简单的说一下客户端访问服务器的工作过程。客户端和服务器之间使用HTTP协议建立TCP连接(<a href="#three">三次握手</a>)，然后客户端发送HTTP请求报文，服务器返回HTTP响应报文，完成访问后，释放TCP连接(<a href="#four">四次挥手</a>)。<br>HTTP的<strong>请求报文</strong>和<strong>响应报文</strong>的区别在于请求报文的开始行叫请求行，响应报文的开始行叫状态行。请求行包括方法、请求资源的URL以及HTTP版本。状态行包括HTTP版本、状态码以及解释状态码的简单短语。在这里解释下__状态码__的含义：</p>
<pre><code>1xx:通知信息。
2xx:成功。
3xx:重定向。
    301:所请求的页面已经转移至新的url
    302:所请求的页面已经临时转移至新的url
4xx:客户机错误。
    401:未授权
    403:所请求的页面被禁止访问
    404:服务器无法找到被请求的页面
5xx:服务器错误。  
    500:请求未完成，服务器遇到不可知的问题   
    502:请求未完成，服务器从上游服务器收到一个无效的响应
    504:网关超时
</code></pre>
<h2 id="Cookie-amp-Session"><a href="#Cookie-amp-Session" class="headerlink" title="Cookie &amp; Session"></a>Cookie &amp; Session</h2><p>HTTP是无状态协议，它没有一个内建机制来维护两个事务之间的状态，但是网站在区别不同用户访问的时候需要进行会话跟踪，所以产生了Cookie和Session。Cookie是通过HTTP请求的头部信息传回服务器的，Session变量的值保存在服务器端(文件&#x2F;数据库&#x2F;缓存中)。<br>当用户访问某个使用Cookie的网站时，该网站的服务器就为此用户产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目，接着在给该用户的HTTP响应报文中添加一个叫Set-cookie的首部行（首部字段名是”Set-cookie”，字段值是”识别码”）。当用户收到响应时，他所使用的浏览器就在它管理的特定Cookie文件中添加一行，包括这个服务器的主机名和识别码，当用户继续访问该网站时，每发送一个HTTP请求报文，其浏览器就会从Cookie文件中取出这个网站的识别码，并放到HTTP请求报文中的Cookie首部行中，这样网站就能跟踪到该用户在该网站的活动。<br>Cookie将数据存储在客户端，但Cookie相对不太安全，单个Cookie的值最大只能存储4k，每次请求都要进行网络传输，占用带宽。Session将用户的会话数据存储在服务端，没有大小限制，通过一个session_id进行用户识别，PHP默认情况下session id是通过Cookie来保存的，因此从某种程度上来说，Session依赖于Cookie，但这不是绝对的，只要能将session id传递到服务端进行识别的机制都可以实现session。如果客户端禁用Cookie,可以使用URL重写，也可以指定通过GET方式或者POST方式把session id传到服务器。</p>
<h2 id="三次握手-amp-四次挥手"><a href="#三次握手-amp-四次挥手" class="headerlink" title="三次握手 &amp; 四次挥手"></a>三次握手 &amp; 四次挥手</h2><p>TCP链接的建立采用客户服务器方式，主动发起连接建立的应用进程叫客户，被动等待连接建立的应用进程叫服务器。</p>
<p><span id="three"></span></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="http://7xsex4.com1.z0.glb.clouddn.com/123.png">	</p>
<ul>
<li>第一次握手：客户端将标志位SYN置为1，选择一个初始序号seq&#x3D;x(随机产生)，并将该数据包发送给服务器，客户端进入SYN-SENT状态，等待服务器确认。</li>
<li>第二次握手：服务器收到数据包后由标志位SYN&#x3D;1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，确认号ack&#x3D;x+1(ack为前一个的seq+1)，也选择一个初始序号seq&#x3D;y，并将该数据包发送给客户端以确认连接请求，服务器进入SYN-RCVD状态。</li>
<li>第三次握手：客户端收到确认后，确认ACK为1，ack是x+1，如果正确则将标志位ACK置为1，ack&#x3D;y+1，自己的序号seq&#x3D;x+1(如果ACK报文段不携带数据则不消耗序号)并将该数据包发送给服务器，服务器检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器进入ESTABLISHED状态，完成三次握手，随后客户端与服务器之间可以开始传输数据了。</li>
</ul>
<p><span id="four"></span> </p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="http://7xsex4.com1.z0.glb.clouddn.com/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png"></p>
<ul>
<li><p>第一次挥手：客户端把连接释放报文段首部的FIN置1,序号seq&#x3D;u(等于前面已传送过的数据的最后一个字节的序号加1),用来关闭客户端到服务器的数据传送，客户端进入FIN-WAIT-1状态。</p>
</li>
<li><p>第二次挥手：服务器收到FIN后，发送一个ACK给客户端，确认号为ack&#x3D;u+1，seq&#x3D;v,服务器进入CLOSE-WAIT状态(A到B关闭，B到A仍未关闭)。A收到B的确认后，进入Fin-WAIT-2状态。</p>
</li>
<li><p>第三次挥手：服务器发送一个FIN，序号seq&#x3D;w，ack&#x3D;u+1,用来关闭服务器到客户端的数据传送，服务器进入LAST-ACK状态。</p>
</li>
<li><p>第四次挥手：客户端收到FIN后，在确认报文段中使ACK&#x3D;1，ack&#x3D;w+1，seq&#x3D;u+1,然后进入TIME-WAIT状态(2MSL，MSL为最长报文段寿命)，服务器进入CLOSED状态，完成四次挥手。　</p>
<p>  TIME-WAIT状态必须等待2MSL的原因：</p>
<ul>
<li>为了保证A发送的最后一个ACK报文段能够到达B，若丢失，B超时重传FIN+ACK报文段。</li>
<li>防止已失效的报文段出现在本连接中，A发送完最后一个ACK报文段后，再经过2MSL，可以使本连接持续的时间内所长生的所有报文段都从网络中消失。</li>
</ul>
</li>
</ul>
<p>　</p>
<h2 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h2><p>HTTP请求方法总共有八种。HTTP1.0定义了三种请求方法：<strong>GET</strong>，<strong>POST</strong>和HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS，PUT，DELETE，TRACE和CONNECT方法。</p>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET用于从指定的资源请求数据，是http的默认请求方式，一般用来获取数据，传输的数据经过url编码后放在路径<code>?</code>之后，多个键值对通过&amp;连接，另外get的传输长度一般不推荐超过255个字节。它一般被视为安全方法，因为它仅用来获取数据而不会对服务器有其他改动。</p>
<blockquote>
<p><strong>安全方法</strong><br>像HEAD、GET、OPTIONS和TRACE这几种http方法是被认为是“安全的”，这意味着它们只会进行数据获取而不会修改服务器的状态，不会产生负面影响，比如记录日志、创建缓存或者创建其他统计信息。<br>像POST、PUT、DELETE和PATCH等方法有可能产生副作用。网络爬虫等一般不会使用这些方式(注:搜索引擎的暗网抓取可能会使用这些方法)。<br>尽管GET方法是一般被视为“安全的”，但如果在实际使用中没有做任何设置，比如可以无限制的抓取等情况，也会导致一些不可预料的问题，比如web缓存或者搜索引擎问题。</p>
</blockquote>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST用于向指定的资源提交要被处理的数据。数据被包含在请求体中，可能会导致新的资源的建立或已有资源的修改。  </p>
<blockquote>
<p>为什么一些请求会使用POST提交数据?  </p>
<ul>
<li>GET请求数据都可以在URL中看到，不应在处理敏感数据时使用，而POST请求数据在URL中是不可见的。  </li>
<li>GET提交的数据都会有长度限制(URL的最大长度是2048个字符)，POST没有长度限制。  </li>
<li>一般规范，GET用来获取数据，POST用来修改数据。  </li>
<li>GET请求可以被缓存，会被保留在浏览器的历史记录中，而POST请求不能被缓存，也不会被保留在浏览器的历史记录中。</li>
<li>GET请求提交的数据放置在HTTP请求协议头中，而POST提交的数据则放在实体数据中。</li>
</ul>
</blockquote>
<h3 id="其他请求方法"><a href="#其他请求方法" class="headerlink" title="其他请求方法"></a>其他请求方法</h3><table>
<tr>
    <td>HEAD</td>
    <td>与 GET 相同，但只返回HTTP报头，不返回文档主体。</td>
</tr>
<tr>
    <td>PUT</td>
    <td>从客户端向服务器传送数据取代指定的文档内容，如果存在则修改内容，否则创建新内容。</td>
</tr>
<tr>
    <td>DELETE</td>
    <td>请求服务器删除指定的页面。</td>
</tr>
<tr>
    <td>TRACE</td>
    <td>返回接受到的请求，用来查看数据经过中间服务器时发生了哪些变动。</td>
</tr>
<tr>
    <td>OPTIONS</td>
    <td>返回服务器支持的所有HTTP方法。</td>
</tr>
<tr>
    <td>CONNECT</td>
    <td>要求使用SSL和TLS进行TCP通信。</td>
</tr>
</table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode</title>
    <url>/2016/04/06/LeetCode/</url>
    <content><![CDATA[<p>本文主要记载自己的刷<a href="https://leetcode.com/">LeetCode</a>经历。</p>
<span id="more"></span>
<h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1.  Two Sum"></a>1.  Two Sum</h3><p><a href="https://leetcode.com/problems/two-sum/">题目</a></p>
<h5 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach #1"></a>Approach #1</h5><p>使用两个for循环，时间复杂度为$O(n^2)$，空间复杂度为:$O(n1)$。</p>
<pre><code>//Runtime:560 ms
class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        int len = nums.size();
        vector&lt;int&gt; result;
        for(int i=0; i&lt;len; i++) &#123;
            for(int j=i+1; j&lt;len;j++) &#123;
                if(nums[i] + nums[j] == target) &#123;
                    result.push_back(i);
                    result.push_back(j);
                    return result;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h5 id="Approach-2"><a href="#Approach-2" class="headerlink" title="Approach #2"></a>Approach #2</h5><p>使用哈希函数组织的map，时间复杂度为$O(n)$，空间复杂度为:$O(n)$。</p>
<pre><code>//Runtime: 16 ms
class Solution &#123;
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;
        int len = nums.size();
        vector&lt;int&gt; result;
        unordered_map&lt;int, int&gt; myMap;
        for(int i=0; i&lt;len; i++) &#123;
            myMap[nums[i]] = i;
        &#125;
        for(int i=0; i&lt;len; i++) &#123;
            int complement = target - nums[i];
            if(myMap.find(complement) != myMap.end() &amp;&amp; myMap[complement] != i) &#123;
                    result.push_back(i);
                    result.push_back(myMap[complement]);
                    return result;
            &#125;
        &#125;
    &#125;
&#125;;
</code></pre>
<h3 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2.  Add Two Numbers"></a>2.  Add Two Numbers</h3><p><a href="https://leetcode.com/problems/add-two-numbers/">题目</a></p>
<h5 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h5><p>使用单向连边，注意点运算符“.”和箭头运算符“-&gt;”都可以用于访问成员，其中点运算获取类对象的一个成员，箭头运算获取指针指向对象的成员。时间复杂度为$O(max(m,n))$，空间复杂度为:$O(max(m,n))$。</p>
<pre><code>//Runtime: 36 ms
class Solution &#123;
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;
        ListNode dummy(0);
        ListNode* result = &amp;dummy;
        int cnt = 0, sum = 0, val = 0;
        
        while (l1 || l2) &#123;
            sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + cnt;
            cnt = sum / 10;
            val = sum % 10;
            result-&gt;next = new ListNode(val);
            result = result-&gt;next;
            if(l1) l1 = l1-&gt;next;
            if(l2) l2 = l2-&gt;next;
        &#125; 
        if(cnt &gt; 0) &#123;
            result-&gt;next = new ListNode(cnt);
        &#125;
        return dummy.next;
    &#125;
&#125;;
</code></pre>
<h3 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.  Longest Substring Without Repeating Characters"></a>3.  Longest Substring Without Repeating Characters</h3><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">题目</a></p>
<h5 id="Approach-1"><a href="#Approach-1" class="headerlink" title="Approach"></a>Approach</h5><p>使用哈希函数组织的map，关键字为字符，对应的值为字符在字符串中的位置。<br><code>l = max(l, myMap[s[r]]+1)</code>用于返回有重复字符时候的左边界位置。  </p>
<ul>
<li><p><strong>tmmzuxt</strong>&amp;emsp;s[l]是第二个m，s[r]是最后一个t，此时不需要更新l。</p>
</li>
<li><p><strong>mmzuxtabt</strong>&amp;emsp;s[l]是第二个m，s[r]是最后一个t，此时需要将l移动至a。  </p>
<pre><code>  //Runtime: 56 ms
  class Solution &#123;
  public:
      int lengthOfLongestSubstring(string s) &#123;
          int len = s.size();
          int l = 0, r = 0, res = 0;
          unordered_map&lt;char, int&gt; myMap;
          while(r &lt; len) &#123;
              if(myMap.find(s[r]) != myMap.end()) &#123;
                  l = max(l, myMap[s[r]]+1);	//返回有重复字符时候的左边界位置
              &#125;
              myMap[s[r]] = r;
              res = max(res, r-l+1);
              r++;
          &#125;
          return res;
      &#125;
  &#125;;
</code></pre>
</li>
</ul>
<p>	</p>
<h3 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6.  ZigZag Conversion"></a>6.  ZigZag Conversion</h3><p><a href="https://leetcode.com/problems/zigzag-conversion/">题目</a></p>
<h5 id="Approach-2"><a href="#Approach-2" class="headerlink" title="Approach"></a>Approach</h5><p>basic_string&lt;&gt;有双重身份，一是代替传统的字符串，所以应该有strlen函数，给出相应的字符串长度；另一个身份是可以用作STL容器，所以要按照STL容器的惯例给出size()。<br>本题的重点是要求出周期$2 * numRows - 2$,然后首行末行的循环周期都是此周期，中间行还需要进行单独计算。    			</p>
<pre><code>//Runtime: 16 ms
class Solution &#123;
public:
    string convert(string s, int numRows) &#123;
        int len = s.size();
        if(numRows &lt; 2)&#123;
            return s;
        &#125;
        string tmp = &quot;&quot;;
        int cnt = 2 * numRows - 2;
        for(int i=0; i&lt;numRows; i++) &#123;
     	    for(int j=i; j&lt;len; j+=cnt) &#123;
                tmp += s[j]; 
                if(i&gt;0 &amp;&amp; i&lt;numRows-1)&#123;		//计算中间行的循环，以cnt为一个循环周期
                	int num = cnt + j - 2 * i;  
                	if(num &lt; len) &#123;
                    	tmp += s[num];    
                  	&#125;
                 &#125;
        	&#125;
        &#125;
        return tmp;
    &#125;
&#125;;
    
</code></pre>
<h3 id="237-Delete-Node-in-a-Linked-List"><a href="#237-Delete-Node-in-a-Linked-List" class="headerlink" title="237.  Delete Node in a Linked List"></a>237.  Delete Node in a Linked List</h3><p><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">题目</a></p>
<h5 id="Approach-3"><a href="#Approach-3" class="headerlink" title="Approach"></a>Approach</h5><p>时间复杂度和空间复杂度都为$O(1)$。</p>
<pre><code>//Runtime: 16 ms
class Solution &#123;
public:
    void deleteNode(ListNode* node) &#123;
        node-&gt;val = node-&gt;next-&gt;val;
        node-&gt;next = node-&gt;next-&gt;next;
    &#125;
&#125;;  
</code></pre>
<h3 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328.  Odd Even Linked List"></a>328.  Odd Even Linked List</h3><p><a href="https://leetcode.com/problems/odd-even-linked-list/">题目</a></p>
<h5 id="Approach-4"><a href="#Approach-4" class="headerlink" title="Approach"></a>Approach</h5><p>若链表非空，至少有一个元素，此时就可看出，while循环的终止条件使用even和even-&gt;next较合适。时间复杂度为$O(n)$，我们需要遍历n个节点；空间复杂度为:$O(1)$，我们所需要的只是4个指针。</p>
<pre><code>//Runtime: 20 ms 
class Solution &#123;
public:
    ListNode* oddEvenList(ListNode* head) &#123;
        if(head == NULL) return NULL;
        ListNode* odd = head;
        ListNode* even = head-&gt;next;
        ListNode* evenHead = even;;
        while(even &amp;&amp; even-&gt;next) &#123;
            odd-&gt;next = even-&gt;next;
            odd = odd-&gt;next;
            even-&gt;next = odd-&gt;next;
            even = even-&gt;next;
        &#125;
        odd-&gt;next = evenHead;
        return head;
    &#125;
&#125;;
</code></pre>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode，algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL笔记</title>
    <url>/2016/02/28/MySQL%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;这些知识点补全，很碎，主要是自己平常不清楚的或者易混淆的。</p>
<span id="more"></span>
<ol>
<li><p><code>mysql -h 主机名 -u 用户名 -p</code><br> -h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略<br> -u : 所要登录的用户名<br> -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项  </p>
</li>
<li><p>MySQL语句以分号为语句的结束, 若在语句结尾不添加分号时, 命令提示符会以 -&gt; 提示你继续输入(有个别特例, 但加分号是一定不会错的)。  </p>
</li>
<li><p>对于一些较长的语句在命令提示符下可能容易输错, 因此我们可以通过任何文本编辑器将语句输入好后保存为.sql 的文件中, 通过命令提示符下的文件重定向执行执行该脚本。打开命令提示符, 输入:<br><code>mysql -D  samp_db -u root -p &lt; createtable.sql</code><br>提示: 如果连接远程主机请加上 -h 指令;createtable.sql文件若不在当前工作目录下需指定文件的完整路径  </p>
</li>
<li><p>A&#x3D;B or A&#x3D;C or A&#x3D;D     A in (‘B’,’C’,’D’)<br> A!&#x3D;B and A!&#x3D;C and A!&#x3D;D   A not in(’B’,’C’,’D’)  </p>
</li>
<li><p>SQL 语句对大小写不敏感。  </p>
</li>
<li><p>如果要插入的字段是auto_increment属性，那么在insert的时候values里要么不注明该字段，要么设为null。</p>
<pre><code> CREATE TABLE Persons (
     P_Id int NOT NULL AUTO_INCREMENT,
     LastName varchar(255) NOT NULL,	
     FirstName varchar(255),
     PRIMARY KEY (P_Id)
 )
</code></pre>
<p> <code>INSERT INTO Persons (FirstName,LastName) VALUES (&#39;Bill&#39;,&#39;Gates&#39;)</code><br> <code>INSERT INTO Persons VALUES (null，&#39;Bill&#39;,&#39;Gates&#39;)</code></p>
</li>
<li><p>MySQL的反引号是为了区分MySQL的保留字与普通字符而引入的符号，如果字段值是字符或字符串，则要加引号。</p>
</li>
<li><p>可从以下几个方面进行优化MySQL(重要性依次降低，成本依次增加）</p>
</li>
</ol>
<ul>
<li>SQL及索引</li>
<li>数据表结构</li>
<li>系统配置</li>
<li>硬件   具体措施：  <ul>
<li>max加索引</li>
<li>count分开查</li>
<li>子查询优化为join</li>
<li>limit限制查询：避免过多的扫描</li>
</ul>
<ul>
<li>使用有索引的列或主键进行order by操作  </li>
<li>记录上次返回的主键，在下次查询时使用主键过滤</li>
</ul>
<ul>
<li>索引</li>
</ul>
<ul>
<li>在where、group by、order by、on从句中出现的列</li>
<li>索引字段越小越好</li>
<li>离散度大的列放到联合索引的前面</li>
<li>索引的维护及优化——删除重复己冗余的索引</li>
</ul>
<ul>
<li>选择合适的数据类型</li>
<li>数据结构优化：表的范式化和反范式化。符合第三范式，要求数据表中不存在非关键字段对任何候选关键字段的传递函数依赖。</li>
<li>数据库结构优化：表的垂直拆分和水平拆分。</li>
<li>系统配置优化</li>
<li>服务器硬件优化</li>
</ul>
</li>
</ul>
<ol start="9">
<li><p>SQL语言包含四个部分：  </p>
<ul>
<li>数据定义语言(DDL):CREATE DROP ALTER</li>
<li>数据操作语言(DML):INSERT UPDATE DELETE</li>
<li>数据查询语言(DQL):SELECT</li>
<li>数据控制语言(DCL):GRANT REVOKE COMMIT ROLLBACK</li>
</ul>
</li>
<li><p>一些典型的SQL语法</p>
<pre><code>INSERT INTO 表名 [(字段名1，字段名2，...，字段名n)] VALUES (&#39;值1&#39;，&#39;值2&#39;，...,&#39;值n&#39;);

UPDATE 表名 
SET 字段名=表达式[,...]
[WHERE 条件]
[ORDER BY 字段]
[LIMIT 行数]；

SELECT [ALL|DISTINCT]
&#123;*|table.*|[table.]field1[AS alias1][,table.|\field2[AS alias2][,...]]&#125; 
FROM tableexpresion[,...][IN externaldatabase] 
[WHERE]
[GROUP BY]
[HAVING]
[ORDER BY]
[LIMIT count];

COUNT() COUNT（*）返回找到的记录行数
SUM() 
AVG()
MAX()
MIN()
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1006</title>
    <url>/2016/03/08/POJ%201006%20/</url>
    <content><![CDATA[<p>POJ 1006<br><a href="http://poj.org/problem?id=1006">题目</a><br>分析：依照<a href="http://baike.baidu.com/view/157384.htm">中国剩余定理</a>解题，关于该定理的分析可参考<a href="http://www.cnblogs.com/walker01/archive/2010/01/23/1654880.html">POJ1006: 中国剩余定理的完美演绎</a>。接下来结合本题进行分析。  </p>
<span id="more"></span>
<p>首先，$n_1 % 23 &#x3D; p， n_2 % 28 &#x3D; e , n_3 % 33 &#x3D; i$。<br>根据公式$ a%b&#x3D;c, (a+k \ast b)%b&#x3D;c $得：<br>$$<br>  \begin{aligned}<br>  (n_1+n_2+n_3) % 23 &#x3D; p,n_2和n_3必须是23的倍数 \<br>  (n_1+n_2+n_3) % 28 &#x3D; e,n_1和n_3必须是28的倍数 \<br>  (n_1+n_2+n_3) % 33 &#x3D; i,n_1和n_2必须是33的倍数<br>  \end{aligned}<br>$$<br>进而得到，$ n_1是28和33的公倍数,n_2是23和33的公倍数,n_3是23和28的公倍数 $。<br>再根据公式$ a%b&#x3D;c, a \ast k%b&#x3D;k \ast c $得<br>$$<br>  \begin{aligned}<br>  n_1 &#x3D; 28 \ast 33 \ast l_1,n_1%23&#x3D;1 \<br>  n_2 &#x3D; 23 \ast 33 \ast l_2,n_2%28&#x3D;1 \<br>  n_1 &#x3D; 23 \ast 28 \ast l_3,n_3%33&#x3D;1<br>  \end{aligned}<br>$$<br>$ l_1,l_2,l_3 $最小为$ l_1&#x3D;6,l_2&#x3D;19,l_3&#x3D;2 $,得到对应的$ n_1&#x3D;5544,n_2&#x3D;14421,n_3&#x3D;1288 $<br>需要注意的是，$ n_1&#x3D;5544,n_2&#x3D;14421,n_3&#x3D;1288 $并只是问题的一个解，不是最小解，最小解为$ (n_1 \ast p+n_2 \ast e+n_3 \ast i) % (23 \ast 28 \ast 33) &#x3D; (n+d) $<br>所以有$ n&#x3D;（5544 \ast p+14421 \ast e+1288 \ast i-d）%21252 $<br>本题所求的是最小整数解，为了避免n为负，最后结果为$ n&#x3D;（5544 \ast p+14421 \ast e+1288 \ast i-d+21252）%21252 $。</p>
<pre><code>/*************************************
Author: Wang Pengzhuang
Date:2016-03-08
Email: wpzhuang@gmail.com
Description: 求最大生理周期
**************************************/

#include&lt;iostream&gt;

using namespace std;

int getMax(int a,int b,int c)&#123;
    int m,n=0;
    for(m=1; n!=1; m++)&#123;
        n=a*b*m%c;
    &#125;
    return a*b*(m-1);
&#125;
int main()&#123;
    int p, e, i, d, n, cnt=1;
    while(cin&gt;&gt;p&gt;&gt;e&gt;&gt;i&gt;&gt;d)&#123;
        if(p==-1 &amp;&amp; e==-1 &amp;&amp; i==-1 &amp;&amp; d==-1)&#123;
            break;
        &#125;
        n = (getMax(28,33,23)*p + getMax(23,33,28)*e + getMax(23,28,33)*i+21252-d)%21252;
        if(n==0)&#123;
            n=21252;
        &#125;
        cout &lt;&lt; &quot;Case &quot; &lt;&lt; cnt &lt;&lt; &quot;: &quot; &lt;&lt; &quot;the next triple peak occurs in &quot; &lt;&lt; n &lt;&lt; &quot; days.&quot; &lt;&lt; endl;
        cnt++;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim配置及常用操作、Linux常用操作</title>
    <url>/2016/02/24/Vim%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>记录使用vim和linux的心得。</p>
<span id="more"></span>
<h2 id="Vim配置"><a href="#Vim配置" class="headerlink" title="Vim配置"></a>Vim配置</h2><pre><code>syntax enable &quot;语法高亮
syntax on &quot;允许用指定语法高亮配色方案替换默认方案
set number &quot;显示行号
set autoindent &quot;使用自动对齐，把当前行的对齐格式应用到下一行	
set laststatus=2 &quot;总是显示状态栏
set cursorline &quot;高亮显示当前行
set hlsearch &quot;高亮显示搜索结果
filetype indent  on &quot;自适应不同语言的智能缩进
set tabstop=4
set shiftwidth=4
set mouse=a		&quot;光标跟随鼠标移动

&quot;Vundle 配置
&quot;filetype on
set nocompatible              &quot; be iMproved, required
filetype off                  &quot; required
&quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

&quot;YouCompleteMe 配置]  
参考：wsmmsh.github.io/2016/02/02/Centos%E5%AE%89%E8%A3%85YouCompleteMe/ 
</code></pre>
<h2 id="Vim常用操作"><a href="#Vim常用操作" class="headerlink" title="Vim常用操作"></a>Vim常用操作</h2><ul>
<li><strong>yy</strong>——复制游标所在行整行  </li>
<li><strong>2yy、y2y</strong>——复制两行  </li>
<li><strong>ggyG</strong>——全选复制  </li>
<li><strong>dd</strong>——剪切游标所在行整行  </li>
<li><strong>2dd、d2d</strong>——剪切两行  </li>
<li><strong>p</strong>——在当前光标处下面粘贴内容  </li>
<li><strong>P</strong>——在当前光标处上面粘贴内容</li>
<li>**#*<em>——往后查找并高亮显示所有光标所在处单词，</em>是往前查找</li>
<li><strong>:sp</strong>——在当前窗口垂直打开新文件</li>
<li><strong>:vsp</strong>——在当前窗口垂直打开新文件</li>
<li><strong>CTRL+W+H&#x2F;J</strong>——多窗口切换</li>
<li><strong>&#x2F;word</strong>——向光标之下寻找一个名称为 word 的字符串。  </li>
<li><strong>？word</strong>——向光标之上寻找一个字符串名称为 word 的字符串。</li>
<li><strong>u</strong>——复原前一个动作。  </li>
<li><strong>CTRL+r</strong>——重做上一个动作。  </li>
<li><strong>.</strong> ——不要怀疑！这就是小数点！意思是重复前一个动作的意思。</li>
</ul>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><ul>
<li><strong>增：</strong>mkdir、vim、touch、systemctl、cd、tar、gzip  </li>
<li><strong>删：</strong>rm、kill  </li>
<li><strong>改：</strong>mv、cp、chmod、chgrp、chown  </li>
<li><strong>查：</strong>cat、ls、ps、history、locate、which、whereis、find、who、pwd、man、grep</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Win7和Centos 7.2.1511的双系统安装</title>
    <url>/2016/01/16/Win7%E5%92%8CCentos-7-2-1511%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>本文针对使用U盘在Windows下安装Centos双系统，Centos版本号为7.2.1511。</p>
<span id="more"></span>
<h2 id="1、安装、重装"><a href="#1、安装、重装" class="headerlink" title="1、安装、重装"></a>1、安装、重装</h2><p>第一次安装的时候，在Windows的磁盘管理里压缩卷，压缩出的空白卷不分配盘符。如果需要重装，则需要把之前装centos的boot盘和centos在的盘删除，不分配盘符。如果分配盘符后在进入centos后的安装界面首页会出现无法识别硬盘的错误。如果重装的时候不小心误删了windows的其他盘符，请使用Diskgenuis软件进行搜索分区修复，注意此功能需要收费版本，免费版没有此功能。<br>安装centos的U盘需要格式化为FAT32，而Centos安装包大于4G，注意在格式化U盘的时候需要在分配单元大小那选择8G，这样安装文件才能写道U盘里，否则无法写入U盘。</p>
<h2 id="2、安装时配置"><a href="#2、安装时配置" class="headerlink" title="2、安装时配置"></a>2、安装时配置</h2><p>在centos的安装界面里可以配置网络，根据自己的实际网络情况选择静态IP或自动获取，需要注意的是新版centos的静态IP在配置文件里的选项为none，而在之前的版本里为static。<br>安装的时候记的选择图形界面，否则进入系统后只有命令行界面。</p>
<h2 id="3、安装完成后"><a href="#3、安装完成后" class="headerlink" title="3、安装完成后"></a>3、安装完成后</h2><p>需要修改centos的启动引导grub，否则重启后无法进入windows选项。此处提供几种修改方法。<br>(1)可修改模板文件，&#x2F;etc&#x2F;grub.d&#x2F;40_custom<br>   在最后加入以下行  </p>
<pre><code>menuentry &#39;win7&#39;&#123; 
   set root=(hd0,1) 
   chainloader +1    
 &#125;
</code></pre>
<p>   然后运行<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code>，此命令可在boot&#x2F;grub2&#x2F;grub.cfg里生成win7引导。注意chainloader和+间有空格。<br>(2)在安装centos系统后，在线安装nfts-3g插件，这样就可以使用<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code>，此命令会自动扫描系统，形成包含windows7的安装选项。    </p>
<pre><code>sudo yum install ntfs-3g    
sudo grub2-mkconfig -o /boot/grub2/grub.cfg more /boot/grub2/grub.cfg
</code></pre>
<p>(3)直接在&#x2F;boot&#x2F;grub2&#x2F;grub.cfg添加，缺点是升级后重新生成的grub文件会覆盖掉。第一种方法实际上就是间接写入grub.cfg。  </p>
<p>参考：<a href="https://wiki.centos.org/zh/HowTos/Grub2">https://wiki.centos.org/zh/HowTos/Grub2</a></p>
<h2 id="4、Win7双系统引导"><a href="#4、Win7双系统引导" class="headerlink" title="4、Win7双系统引导"></a>4、Win7双系统引导</h2><p>经过第三步后，重启电脑我们就可以在启动选项里选择win7，如果觉得这种启动方式不方便，我们还可以在win7里使用easybcd进行启动引导，推荐选择这样的双系统启动方式。<br>参考：<a href="http://tieba.baidu.com/p/3191017719">http://tieba.baidu.com/p/3191017719</a></p>
<h2 id="5、常用软件"><a href="#5、常用软件" class="headerlink" title="5、常用软件"></a>5、常用软件</h2><ul>
<li><p><strong>Firefox</strong>： centos的系统安装包里带的firefox都是旧版的，要想使用最新版的可以去火狐官网下载压缩包，直接解压就可以使用了，此时如果安装了flash重启浏览器后还是提示没有flash，需要把flash安装后的.so文件进行移动：<br> <code>sudo cp libflashplayer.so/usr/lib/mozilla/plugins</code></p>
</li>
<li><p><strong>Chrome</strong>：从官网下载rpm安装包后，在命令行下进行启动，启动命令：<br> <code>google-chrome --no-sandbox --user-data-dir</code><br>或者在opt&#x2F;google&#x2F;chrome里面，以文本方式打开google-chrome，在<br> <code>exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot;</code><br>后面添加语句，注意之间的空格和两横杆。<br><code>exec -a &quot;$0&quot; &quot;$HERE/chrome&quot;  &quot;$@&quot; --no-sandbox --user-data-dir</code><br><font face="微软雅黑" size=4>注意</font>此处的chrome启动不使用沙盒，可能对安全性有所影响。</p>
</li>
<li><p><strong>VLC</strong>：无法启动，查看系统日志发现是提示无法使用root启动。执行以下命令：<br> <code>sed -i &#39;s/geteuid/getppid/&#39; /usr/bin/vlc</code>  </p>
</li>
<li><p><strong>搭建LAMP</strong><br>  <em><strong>(1)安装Apache</strong></em>    </p>
<pre><code> yum install httpd		  
 systemctl start httpd.service		  
 systemctl enable httpd.service		
</code></pre>
<p>  <em><strong>(2)安装MySQL</strong></em>  </p>
<pre><code> wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm
 rpm -ivh mysql-community-release-el7-5.noarch.rpm
 yum install mysql-community-server
 systemctl enable mysqld
 systemctl start mysqld
 mysql_secure_installation  
</code></pre>
<p> 参考:<a href="http://www.ahlinux.com/centos/23340.html">http://www.ahlinux.com/centos/23340.html</a></p>
<p> <em><strong>(3)安装PHP</strong></em>  </p>
<pre><code> yum install php		
 yum -y install php-mysql php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel		  
</code></pre>
<p> <em><strong>(4)安装phpMyAdmin</strong></em></p>
<pre><code> yum install phpmyadmin
 systemctl restart httpd
 http://server_domain_or_IP/phpMyAdmin
</code></pre>
<p> 参考：<a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-phpmyadmin-with-apache-on-a-centos-7-server">https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-phpmyadmin-with-apache-on-a-centos-7-server</a></p>
</li>
</ul>
<p>参考：<a href="http://seisman.info/how-to-install-softwares-under-centos-7.html">http://seisman.info/how-to-install-softwares-under-centos-7.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>URL中&quot;#&quot;、&quot;&amp;&quot;和&quot;？&quot;的作用</title>
    <url>/2016/06/26/URL%E4%B8%AD%E8%8B%A5%E5%B9%B2%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>在本文中我总结了下**#<strong>、</strong>？<strong>、</strong>&amp;**在URL中的作用。</p>
<span id="more"></span>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>URL中的#代表网页中的一个位置，其右边的字符就是该位置的标识符。比如<code>http://www.example.com/index.html#print</code>就代表网页index.html的print位置。浏览器在读取这个URL后，会自动将print位置滚动至可视区域。为网页位置指定标识符有两个方法:<strong>使用锚点</strong>，比如<code>&lt;a name=&quot;print&quot;&gt;&lt;/a&gt;</code>；** 使用id属性 **，比如<code>&lt;div id=&quot;print&quot;&gt;</code>。#在URL中的具体作用如下：  </p>
<ol>
<li><p>HTTP请求不包括#，改变#不触发网页重载，但会改变浏览器的访问历史<br>#是用来指导浏览器动作的，对服务器端完全无用，所以HTTP请求中不包括#。比如，访问下面的网址，<code>http://www.example.com/index.html#print</code>，浏览器实际发出的请求是这样的：</p>
<pre><code> GET /index.html HTTP/1.1
 Host: www.example.com
</code></pre>
</li>
</ol>
<p>单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。比如，从<code>http://www.example.com/index.html#location1</code>改为<code>http://www.example.com/index.html#location2</code>，浏览器不会重新向服务器 请求index.html。<br>每次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮就可以回到上一个位置。这对于ajax应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。</p>
<ol start="2">
<li><p>#后面的内容不会被发送到服务器端<br>在第一个#后面出现的任何字符都会被浏览器解读为位置标识符，这些字符都不会被发送到服务器端。<br>比如，下面URL的原意是指定一个颜色值：<code>http://www.example.com/?color=#fff</code>，但是浏览器实际发出的请求是：</p>
<pre><code> GET /?color= HTTP/1.1
 Host: www.example.com  
</code></pre>
</li>
<li><p>可以通过javascript使用window.location.hash来改变#后面的值<br><code>window.location.hash</code>这个属性可以对URL中的#参数进行修改，基于这个原理，我们可以在不重载页面的前提下创造一条新的访问记录。<br>除此之外，HTML 5新增了onhashchange事件，当#值发生变化时就会触发这个事件。  </p>
</li>
<li><p>Google抓取#的机制<br>默认情况下，Google的网络蜘蛛忽视URL的#部分。但Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用”#!”，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。比如，Google发现新版twitter的URL：<code>http://twitter.com/#!/username</code>，就会自动抓取另一个URL：<code>http://twitter.com/?_escaped_fragment_=/username</code>。通过这种机制，Google就可以索引动态的Ajax内容。</p>
</li>
</ol>
<h2 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h2><p>**&amp;**是URL中指定的参数间的分隔符。  </p>
<h2 id="-1"><a href="#-1" class="headerlink" title="?"></a>?</h2><p>**?**在URL中一般有两种作用：</p>
<ul>
<li><p>连接作用：比如<code>http://www.example.com/Show.asp?id=77&amp;nameid=2905210001&amp;page=1</code>。  </p>
</li>
<li><p>清除缓存：比如</p>
<pre><code>  http://www.example.com/index.html  
  http://www.example.com/index.html?test123123
</code></pre>
<p>  两个url打开的页面一样，但后面这个有问号，说明不调用缓存的内容，而是重新读取一个新地址。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>hexo博客搭建</title>
    <url>/2016/01/09/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>这是我的第一篇github博客，鼓捣了好几天总算是搭建好了，总结下搭建整个环境的步骤吧。在真实搭建的时候参考了很多网上的资料，也走了很多弯路，在此按着正确的思路进行一下总结。</p>
<span id="more"></span>
<h2 id="1、安装git、node-js、hexo"><a href="#1、安装git、node-js、hexo" class="headerlink" title="1、安装git、node.js、hexo"></a>1、安装git、node.js、hexo</h2><p>这个属于前期工作，具体的可以参考hexo的官方教程。<br>参考：<a href="https://hexo.io/zh-cn/docs/">Hexo官方中文文档</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="http://zipperary.com/2013/05/28/hexo-guide-2/">搭建hexo博客</a>  </p>
<h2 id="2、hexo配置、优化"><a href="#2、hexo配置、优化" class="headerlink" title="2、hexo配置、优化"></a>2、hexo配置、优化</h2><p>我使用的主题是NexT，大家可以在hexo的主题列表里选择自己喜欢的。站点配置文件的设置可以参考<a href="http://zipperary.com/2013/05/29/hexo-guide-3/">hexo博客的配置使用</a>，主题配置文件的可以参考你选择的主题的配置。<br>参考：<a href="http://theme-next.iissnan.com/">NexT使用文档</a><br>&amp;emsp;&amp;emsp;&amp;emsp;<a href="https://github.com/iissnan/hexo-theme-next/wiki/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83">NexT主题配置参考</a>  </p>
<h2 id="3、hexo部署相关"><a href="#3、hexo部署相关" class="headerlink" title="3、hexo部署相关"></a>3、hexo部署相关</h2><p>在本地写完博客或者对博客进行修改后，每次都需要<code>hexo g</code>来重新生成文件，然后push到github端，在deploy的时候为了避免每次都需要重新输入github的账号和密码，可以添加SSH，此处SSH的作用相当于一把钥匙，当装着这把钥匙的电脑deploy的时候就无需再次输入github的账号密码。添加SSH的具体做法参考<a href="https://help.github.com/articles/generating-an-ssh-key/">Generating an SSH key</a>。<br>如果你在添加SSH后发现部署的时候仍然需要输入用户名密码，那么需要在你的站点配置文件(站点目录里的__config.yml)里进行修改，	在deploy里，把repo的地址从<code>https://github.com/USERNAME/REPOSITORY.git</code>改为<code>git@github.com:USERNAME/OTHERREPOSITORY.git</code>。原因是你之前使用的是https进行本地和远程github的连接，你使用SSH的时候自然也需要把链接改成SSH链接。<br>当然你也可以选择使用github桌面客户端来进行上传，此时和本地和远程的链接使用的HTTPS，无需在在本地添加SSH密钥。<br>参考：<a href="https://help.github.com/articles/which-remote-url-should-i-use/#cloning-with-https-urls-recommended">Which remote URL should I use?</a><br>&amp;emsp;&amp;emsp;&amp;emsp;重点参考里面的<code>Cloning with HTTPS URLs</code>和<code>Cloning with SSH URLs</code>。  </p>
<h2 id="4、hexo配置"><a href="#4、hexo配置" class="headerlink" title="4、hexo配置()"></a>4、hexo配置()</h2><ul>
<li><p>支持数学公式<br><code>npm install hexo-math --save</code><br>在站点_config.yml里添加</p>
<pre><code>  plugins: 
        hexo-math
</code></pre>
</li>
</ul>
<p>参考资料：<br>(1)<a href="http://ibruce.info/2013/11/22/hexo-your-blog/">hexo你的博客</a><br>(2)<a href="http://www.ituring.com.cn/article/23">怎样使用Markdown</a><br>(3)<a href="http://wowubuntu.com/markdown/basic.html">Markdown: Basics （快速入门）</a><br>(4)<a href="http://wowubuntu.com/markdown/index.html">Markdown 语法说明 (简体中文版)</a><br>(5)<a href="http://lowrank.science/Hexo-Migration/">多机更新 Hexo 博客</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo再折腾</title>
    <url>/2021/06/29/hexo%E5%86%8D%E6%8A%98%E8%85%BE/</url>
    <content><![CDATA[<p>转眼间，自己已经从学校毕业走入职场，打算重新拾起博客，记录学习的历程。因为之前的博客是在实验室电脑上更新的，离开学校想要继续写博客，需要在工作电脑上重新搭建博客环境。自己折腾了许久，主要记录下迁移过程中的一些问题吧。  </p>
<span id="more"></span>
<h2 id="1、hexo迁移"><a href="#1、hexo迁移" class="headerlink" title="1、hexo迁移"></a>1、hexo迁移</h2><p>若更换电脑还想保留原博客，需要注意备份包含<code>yourname.github.io</code>所在的整个博客目录。在新电脑重新安装git和Node.js后，使用npm安装hexo。然后<code>hexo init</code>新建博客目录后，将之前博客目录里的<code>_config.yml</code>文件和别的比如post里之前的文章也放到新的目录里，这样你就可以接着之前的进度进行更新，不会丢失掉以前的内容，说白了是把以前的文档先copy到本地，然后在此基础上继续更新，毕竟博客在github里面都是在yourname.github.io里面保存着的。需要注意的是在新电脑上需要重新添加git的SSH key，这样新电脑才可以<code>hexo deploy</code>新文章。  </p>
<h2 id="2、数学公式"><a href="#2、数学公式" class="headerlink" title="2、数学公式"></a>2、数学公式</h2><p>下面我的博客和主题的版本信息：  </p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo</span>: <span class="number">3</span>.<span class="number">4</span>.<span class="number">2</span></span><br><span class="line"><span class="attribute">next</span>主题 version: <span class="number">5</span>.<span class="number">1</span>.<span class="number">3</span> </span><br></pre></td></tr></table></figure>
<p>之前搭建博客的时候，写数学公式主要是用的hexo-math插件，但重新安装的时候各种调不出来，决定使用next主题自带的</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span>  </span><br></pre></td></tr></table></figure>
<p>这样可以不使用插件就能正常渲染公式。需要注意的需要在有公式的文章的Front-matter区域添加<code>mathjax: true</code>，这样就能正常显示公式了。<br>自此，博客已经在新电脑上生根发芽，希望以后能够坚持记录自己学到的一些东西吧。  </p>
<h2 id="3、博客功能丰富"><a href="#3、博客功能丰富" class="headerlink" title="3、博客功能丰富"></a>3、博客功能丰富</h2><p>另外，给自己的博客使用leancloud添加了评论和文章阅读量统计功能。</p>
<h2 id="4、网站访问量统计"><a href="#4、网站访问量统计" class="headerlink" title="4、网站访问量统计"></a>4、网站访问量统计</h2><p>使用了不蒜子的服务，注意在本地调试的时候网站访问量会报错，但上传github后显示正常。</p>
<h2 id="5、插入图片"><a href="#5、插入图片" class="headerlink" title="5、插入图片"></a>5、插入图片</h2><p>这块绝对引用没有试成功，使用了路过图床。</p>
<h2 id="6、Valine配置-20210814未完成评论推送邮箱设置"><a href="#6、Valine配置-20210814未完成评论推送邮箱设置" class="headerlink" title="6、Valine配置(20210814未完成评论推送邮箱设置)"></a>6、Valine配置(20210814未完成评论推送邮箱设置)</h2><ul>
<li>建议配置Valine使用国际版的LeanCloud，因为国内版已经不会再给一个免费的二级域名。当然有自己备案域名的无所谓。  </li>
<li>注意不仅需要在LeanCloud里创建Class，还需在Class下面创建存储Counter。</li>
</ul>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>(1)<a href="http://theme-next.iissnan.com/third-party-services.html">第三方服务集成</a><br>(2)<a href="http://busuanzi.ibruce.info/">两行代码 搞定计数(不蒜子)</a><br>(3)<a href="https://blog.csdn.net/weixin_39345384/article/details/80787998">NexT主题下，用Leancloud统计文章阅读量</a><br>(4)<a href="https://www.cnblogs.com/hugochen1024/p/12570656.html#2046903411">Hexo博客插入图片的方法</a><br>(5)<a href="https://www.pianshen.com/article/76061484709/">Valine评论之Valine-admin配置攻略</a><br>(6)<a href="https://blog.csdn.net/qq_33154343/article/details/114580553">Hexo 部署 valine 评论的 leancloud 设置</a>  
 </p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell笔记</title>
    <url>/2016/03/03/shell%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>&amp;emsp;&amp;emsp;Shell在用户和计算机硬件之间起翻译作用,Shell编程的目的是简化管理操作,它是一种弱类型语言，是用C语言编写的程序。开头必须是<code>#!/bin/bash</code>,其中<code>#!</code>告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程序。</p>
<span id="more"></span>
<h3 id="Bash变量"><a href="#Bash变量" class="headerlink" title="Bash变量"></a>Bash变量</h3><p>&amp;emsp;&amp;emsp;变量名必须以字母下划线开头，中间只能有字母、下划线和数字组成,默认类型都是字符串型，Bash只支持一维数组。<br>&amp;emsp;&amp;emsp;变量分类——<strong>用户自定义变量、环境变量、预定义变量和位置参数变量</strong>。<br>&amp;emsp;&amp;emsp;用户自定义变量是局部变量，等号两边不能有空格，如果变量值有空格，需要加双引号,调用前需要加<code>$</code>。<br>&amp;emsp;&amp;emsp;环境变量是全局变量,PATH（系统查找命令的路径）, locale（当前语系查询）。<br>&amp;emsp;&amp;emsp;  预定义变量：<code>$?</code>最后一次执行的命令的返回状态,<code>$$</code>当前进程的进程号(PID),<code>$!</code>后台进行的最后一个进程的进程号(PID)<br>&amp;emsp;&amp;emsp;位置参数变量:<code>$n</code>代表参数位置,<code>$*</code>看成整体, <code>$@</code>分别对待, <code>$#</code>返回变量个数。</p>
<h3 id="Shell运算符"><a href="#Shell运算符" class="headerlink" title="Shell运算符"></a>Shell运算符</h3><p>&amp;emsp;&amp;emsp;Shell运算符分为算数运算符、关系运算符、布尔运算符、字符串运算符、文件测试运算符。  </p>
<ul>
<li><p>**算数运算符:**原生bash不支持简单的数学运算，但是可以通过其他命令来实现。  </p>
<ul>
<li>awk和expr，expr最常用，weight&#x3D;`expr 1+1`。</li>
<li>let表示数学运算，<code>let “weight+1”</code> or <code>let “weight=$weight+1”</code>。  </li>
<li>(())——运算符, <code>((weight+1))</code> or <code>((weight=$weight+1))</code>。</li>
<li>$[ ]将中括号内的表达式作为数学运算先计算结果再输出,<code>Weight=$[$weight+1]</code>。</li>
</ul>
</li>
<li><p>**关系运算符:**只支持数字，不支持字符串，除非字符串的值是数字。</p>
</li>
<li><p><strong>布尔运算符:</strong> !，-o，-a。</p>
</li>
<li><p><strong>字符串运算符</strong></p>
</li>
<li><p><strong>文件测试运算符：</strong>用于检测Unix文件的各种属性。<br>参考：<a href="http://www.runoob.com/linux/linux-shell.html">Shell编程</a></p>
<h3 id="Shell函数"><a href="#Shell函数" class="headerlink" title="Shell函数"></a>Shell函数</h3><p>&amp;emsp;&amp;emsp;在Shell中的所有函数在使用前必须定义，这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<pre><code>  [function] funname [()]
  &#123;
      action;
      [return int;]
  &#125;
</code></pre>
</li>
</ul>
<p>注：$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;&#x3D;10时，需要使用${n}来获取参数。  </p>
<h3 id="Shell输入-x2F-输出重定向"><a href="#Shell输入-x2F-输出重定向" class="headerlink" title="Shell输入&#x2F;输出重定向"></a>Shell输入&#x2F;输出重定向</h3><p>&amp;emsp;&amp;emsp;0是标准输入（STDIN），1是标准输出（STDOUT），2是标准错误输出（STDERR）。</p>
<pre><code>    &gt;	    将命令输出写入文件
    &gt;&gt; 	    将命令追加到文件
    &amp;&gt;&gt;     将正确错误命令都可以追加到文件里
    命令&gt;&gt;文件1 2&gt;&gt;文件2   正确命令写入文件1，错误写入文件2  
</code></pre>
<h3 id="Shell正则表达式"><a href="#Shell正则表达式" class="headerlink" title="Shell正则表达式"></a>Shell正则表达式</h3><p>&amp;emsp;&amp;emsp;正则表达式主要用于字符串的模式分割、匹配、查找及替换操作，正则是包含匹配，通配符用来匹配符合条件的文件名，通配符是完全匹配。</p>
<pre><code>    \*   	匹配任意内容
    ？	    匹配任意一个内容
    []  	匹配中括号中的一个字符
    \d      任意一个十进制数字
    \s      任意一个空白字符
    \w      任意一个数字、字母、下划线
    ^		在[]外代表开头，在[]内代表取反
    *=&#123;0,&#125;,	+=&#123;1,&#125;,?=&#123;0,1&#125;
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>shell linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解计算机系统》读书笔记</title>
    <url>/2016/07/17/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>花了大概一个多月的时间，趁着实习的空闲把这本书看完了，感觉本书对于计算机的整个宏观讲的很不错，但在操作系统方面讲的还不够深入，自己看这本书主要是为了自己以后的校招做准备，弥补下自己在操作系统方面的短板。</p>
<span id="more"></span>  

<ol>
<li><p>外壳是一个命令行解释器，它输出一个提示符，等待你输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的外壳命令，那么外壳就假设这是一个可执行文件的名字，它将加载并运行这个文件。  </p>
</li>
<li><p>驱动计算机进步的两大动力：  </p>
<ul>
<li>要计算机做的更多——并发（一个同时具有多个活动的系统）</li>
<li>要计算机做的更快——并行（用并发使系统运行的更快）</li>
</ul>
</li>
<li><p>同变量类似，指针也有两个方面：  </p>
<ul>
<li>值（表示某个对象的地址）  </li>
<li>类型（表示那个位置上存储的对象的类型）</li>
</ul>
</li>
<li><p>对于一个字长为w位的机器而言，虚拟地址的范围为$0\sim2^w$，程序最多访问$2^w$个字节。  </p>
</li>
<li><p>多字节对象都被存储为连续的字节序列，对象的地址为所使用字节的最小地址。 </p>
</li>
<li><p>Unix外壳创建的每个进程开始时都有三个打开的文件：标准输入（0）、标准输出（1）和标准错误（2）。头文件&lt;unistd.h&gt;定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述值。  </p>
</li>
<li><p>Unix内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向v-node表。每个进程都有自己单独的描述符表，所有的进程共享同一个打开文件表和v-node表。  </p>
</li>
<li><p>客户端-服务器模型中的基本操作是事务（跟数据库事务完全不一样），它由四步组成：客户端发送请求；服务器处理请求；服务器发送响应；客户端处理响应。  </p>
</li>
<li><p>编写高效程序需要做到以下几点：  </p>
<ul>
<li>必须选择一种合适的数据结构和算法。  </li>
<li>必须编写出编译器能够有效优化以转换成可执行代码的源代码。</li>
<li>对处理运算量特别大的计算，将一个任务分成多个部分。</li>
</ul>
</li>
<li><p>在一个使用投机执行的处理器中，处理器会开始执行预测的分支目标处的指令,这样做会避免修改任何实际的寄存器或存储器位置，知道确定了实际的结果。如果预测是正确，那么处理器就会“提交”投机执行的指令的结果，把它们存储到寄存器或存储器中。如果预测是错误的，处理器必须丢弃掉所有投机执行的结果，在正确的位置，重新开始取指令的过程。这样做会引起预测错服除法，因为在产生又有用的结果前，必须重新填充指令流水线。为保证分之预测除法不会阻碍程序的效率，可以使用以下原则：</p>
<ul>
<li><p>不要过分关系可预测的分支。</p>
</li>
<li><p>书写使用条件传送的代码，使用“功能式的”代码替代“命令式的”代码。</p>
<pre><code>  #命令式
  if(a[i] &gt; b[i]) &#123;
    int t = a[i];
    a[i] = b[i];
    b[i] = t;
  &#125;
  #功能式
  int min = a[i] &lt; b[i] ? a[i] : b[i];
  int max = a[i] &lt; b[i] ? b[i] : a[i];
  a[i] = min;
  b[i] = max;
</code></pre>
</li>
</ul>
</li>
<li><p>优化程序性能的基本策略：  </p>
<ul>
<li>高级设计。为遇到的问题选择适当的算法和数据结构。</li>
<li>基本编码原则。<ul>
<li>消除连续的函数调用，在可能时将循环移到循环外。</li>
<li>消除不必要的存储器引用，引入临时变量来保存中间结果。</li>
</ul>
</li>
<li>低级优化。<ul>
<li>展开循环，降低开销。</li>
<li>用功能的风格重写条件操作，使得编译采用条件数据传递。</li>
</ul>
</li>
</ul>
</li>
<li><p>Amdahl定律：考虑一个系统，在其中执行某个应用程序需要时间，假设系统的某个部分需要这个时间的百分比为$\alpha$，而我们将它的性能提高到了$k$倍，即这个部分原来$ \sum_{i&#x3D;0}^n i^2 &#x3D; \frac{(n^2+n)(2n+1)}{6} $需要时间$\alpha\bulletT_{old}$，而现在需要时间$\alphaT_{old}&#x2F;k$ ，因此整个执行时间会是：<br>$$T_{new}&#x3D;(1-\alpha)T_{old}+(\alphaT_{old})&#x2F;k$&#x3D;T_{old}[(1-\alpha)+\alpha&#x2F;k]$$<br>据此，我们可以计算加速比$S&#x3D;T_{old}&#x2F;T_{new}$为：$S&#x3D;\frac{1}{(1-\alpha)+\alpha&#x2F;k}$。要想大幅度提高整个系统的速度，我们必须提高整个系统很大一部分的速度。  </p>
</li>
<li><p>一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身，这种倾向性被称为局部性原理，这是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响，分为时间局部性和空间局部性。  </p>
</li>
<li><p>量化评价程序局部性的原则：</p>
<ul>
<li>重复引用一个变量的程序有良好的时间局部性。</li>
<li>对于具有步长为k的引用模式的程序，步长越小，空间局部性约好。具有步长为1的引用模式的程序有很好的空间局部性，在存储器中以大步长跳来跳去的程序空间局部性会很差。</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li>
</ul>
</li>
<li><p>高速缓存的写操作：</p>
<ul>
<li>直写：立即将w的高速缓存块协会到紧接着的低一层中。虽然简单，但缺点是每次写都会引起总线流量。</li>
<li>写回：尽可能的推迟存储器更新，只有当替换算法要驱逐更新过的块时，才把它写到紧接着的低一层中。能显著地减少总线流量，但是增加了复杂性。</li>
</ul>
</li>
<li><p>基本存储技术包括随机存储器(RAM)、非易失性存储器(ROM，只读存储器)和磁盘。RAM包括静态RAM(SRAM，贵、快，可作CPU芯片上的高速缓存，也可以用作芯片下的高速缓存)和动态RAM(DRAM，便宜、慢，用作主存和图形帧缓冲区)。  </p>
</li>
<li></li>
</ol>
<p><img src="http://7xsex4.com1.z0.glb.clouddn.com/C%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C.png" alt="C程序编译执行示意图"><br>之后Unix外壳调用操作系统中的加载器函数，它拷贝可执行文件中的代码和数据到存储器，然后将控制转移到这个程序的开头。<br>18. 程序是一堆代码和数据，可以作为目标模块存放于磁盘上，或者作为段存在于地址空间中。进程是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文的。上下文是由程序正确运行所需的状态组成的，包括存放在存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。<br>19. 进程提供给应用程序的关键抽象：<br>    * 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。<br>    * 一个私有的地址空间，它提供一个假象，好像我们的程序的独占地使用存储器系统。<br>20. 多个流并发地执行的一般现象称为并发，一个进程和其他进程轮流运行的概念称为多任务；<br>21. 上下文切换：<br>    * 保存当前进程的上下文。<br>    * 回复某个先前被抢占的进程的被保存的上下文。<br>    * 将控制传递给这个新恢复的进程。<br>22. 一个终止了但还未被回首的进程称为僵死进程。<br>23. fork是一次调用两次返回：一次是在调用进程（父进程）中，返回子进程的pid；一次是在新创建的子进程中，返回0。因为子进程的pid总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。<br>24. 虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。它有三个重要能力：<br>    * 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只包括活动区域，并根据需要在磁盘和主存见来回传送数据，高效地使用主存。<br>    * 为每个进程提供了一致的地址空间，从而简化了存储器管理。<br>    * 保护每个进程的地址空间不被其他进程破坏。<br>25. 对于C语言来说，常见的管理和使用虚拟存储器的错误有：<br>    * 间接引用坏指针。<br>    * 读取未初始化的存储器。<br>    * 允许栈缓冲区溢出。<br>    * 假设指针和它们指向的对象大小相同。<br>    * 引用指针而不是它们所指向的对象。<br>    * 误解指针运算。<br>    * 引用不存在的变量，引起内存器泄漏。  </p>
<p><font color=#FF0000>注：12条公式错误没解决</font></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/2016/03/26/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p>所谓遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。遍历是二叉树最重要的运算之一，是二叉树上进行其它运算的基础。</p>
<span id="more"></span>
<p>根据访问结点操作发生位置命名：  </p>
<ol>
<li>前序遍历(Preorder Traversal)，访问根结点的操作发生在遍历其左右子树之前。  </li>
<li>中序遍历(Inorder Traversal)，访问根结点的操作发生在遍历其左右子树之中。  </li>
<li>后序遍历(Postorder Traversal)，访问根结点的操作发生在遍历其左右子树之后。  </li>
<li>层序遍历(Level-order Traversal)，所有深度为d的结点要在深度为d+1的节点之前处理。由于它用的较少，所以本文不对它进行讨论。</li>
</ol>
<p>注：由于先左后右和先右后左对称，故本文只讨论先左后右的三种次序。</p>
<h2 id="二叉树节点定义"><a href="#二叉树节点定义" class="headerlink" title="二叉树节点定义"></a>二叉树节点定义</h2><p>二叉树节点使用以下数据结构进行表示，包括关键字、左儿子、右儿子属性和一个带默认参数的构造函数。</p>
<pre><code>struct TreeNode &#123;
    public:
        int val;
        TreeNode *left, *right;
        TreeNode(int v = 0, TreeNode *l = NULL, TreeNode *r = NULL) 
        :val(v), left(l), right(r) &#123; &#125;
    &#125;;
</code></pre>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树遍历的实现方式主要有三种：递归遍历，非递归遍历和Morris遍历。</p>
<h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>递归遍历的实现非常简单，按照遍历的次序，对当前结点分别调用左子树和右子树即可。此时每个结点只需遍历一次，故时间复杂度为O(n)。最差情况下递归调用的深度为O(n)，所以空间复杂度为O(n)。</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><pre><code>void preOrder(TreeNode *root) &#123;
    if(root == NULL) &#123;
        return; 
    &#125;
    cout &lt;&lt; root-&gt;val &lt;&lt;endl;
    preOrder(root-&gt;left);
    preOrder(root-&gt;right);	
&#125;
/*void函数如果想在它们的中间位置提前退出，可以使用return语句，此时return有点类似break；
  只要函数的返回类型不是void，则每条return语句必须返回一个值。*/ 
</code></pre>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><pre><code>void inOrder(TreeNode *root)  &#123;
    if(root == NULL) &#123;
        return;
    &#125;
    inOrder(root-&gt;left);
    cout &lt;&lt; root-&gt;val &lt;&lt;endl;
    inOrder(root-&gt;right);		
&#125;
</code></pre>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><pre><code>void postOrder(TreeNode *root)  &#123;
    if(root == NULL) &#123;
        return;
    &#125;
    postOrder(root-&gt;left);
    postOrder(root-&gt;right);		
    cout &lt;&lt; root-&gt;val &lt;&lt;endl;
&#125;
</code></pre>
<h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p>递归算法的本质是利用函数的调用栈进行，实际上我们可以自行使用栈来进行模拟，实现二叉树遍历的非递归实现。此时每个结点只需遍历一次，故时间复杂度为O(n)，空间复杂度为O(h),h为二叉树的高度。</p>
<h4 id="前序遍历-1"><a href="#前序遍历-1" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>首先把根节点入栈，然后在每次循环中执行以下操作：</p>
<ul>
<li><p>此时栈顶元素即为当前的根节点，弹出并打印当前的根节点；</p>
</li>
<li><p>把当前根节点的右儿子入栈；</p>
</li>
<li><p>把当前根节点的左儿子入栈。</p>
<pre><code>  void preOrder2(TreeNode *root)  &#123;
      if(root == NULL) &#123;
          return;
      &#125;
      stack&lt;TreeNode *&gt; stk;
      stk.push(root);
      while(!stk.empty()) &#123;
          TreeNode *pNode = stk.top();
          stk.pop();
          cout &lt;&lt; pNode-&gt;val &lt;&lt; endl;
          if(pNode-&gt;left) &#123;
              stk.push(pNode-&gt;left);
          &#125;
          if(pNode-&gt;right) &#123;
              stk.push(pNode-&gt;right);
          &#125;

      &#125;
  &#125;
</code></pre>
</li>
</ul>
<h4 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h4><ol>
<li><p>初始化一个二叉树结点pNode指向根结点；</p>
</li>
<li><p>若pNode非空，那么就把pNode入栈，并把pNode变为其左儿子，直到最左边的结点；</p>
</li>
<li><p>若pNode为空，弹出栈顶的结点，并访问该结点，将pNode指向其右儿子。</p>
<pre><code> void inOrder2(TreeNode *root) &#123;
     if(root == NULL) &#123;
         return;
     &#125;
     stack&lt;TreeNode *&gt; stk;
     TreeNode *pNode = root;
     while(pNode || !stk.empty()) &#123;
         if(pNode) &#123;
             stk.push(pNode);
             pNode = pNode-&gt;left;
         &#125; else &#123;
             pNode = stk.top();
             stk.pop();
             cout &lt;&lt; pNode-&gt;val &lt;&lt; endl;
             pNode = pNode-&gt;right;
         &#125;
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<h4 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>因为后序遍历的顺序是：左子树-&gt;右子树-&gt;根节点，于是我们在前序遍历的代码中，当访问完当前节点后，先把当前节点的左子树入栈，再把右子树入栈，这样最终得到的顺序为：根节点-&gt;右子树-&gt;左子树，刚好是后序遍历倒过来的版本，于是把这个结果做一次翻转即为真正的后序遍历。而翻转可以通过使用另外一个栈简单完成，这样的代价是需要两个栈，但就复杂度而言，空间复杂度仍然是O(h)。</p>
<pre><code>    void postOrder2(TreeNode *root)  &#123;
        if(root == NULL) &#123;
            return;
        &#125;
        stack&lt;TreeNode *&gt; stk1,stk2;
        stk1.push(root);
        while(!stk1.empty()) &#123;
            TreeNode *pNode = stk1.top();
            stk1.pop();
            stk2.push(pNode);
            if(pNode-&gt;right) &#123;
                stk1.push(pNode-&gt;right);
            &#125;
            if(pNode-&gt;left) &#123;
                stk1.push(pNode-&gt;left);
            &#125;
        &#125;
        while(!stk2.empty()) &#123;
            cout &lt;&lt; stk2.top()-&gt;val &lt;&lt; endl;
            stk2.pop();
        &#125;
    &#125;  
</code></pre>
<h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p>Morris遍历的神奇之处在于它是非递归的算法，且不需要额外的O(h)的空间，而且复杂度仍然是线性的。这样的算法最关键的问题是当访问完一棵子树后，如何回到其对于的根节点再继续访问右子树呢？Morris是通过修改二叉树某些节点的指针来做到的。</p>
<h4 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>按照定义，在中序遍历中，对于一棵以root为根的二叉树，当访问完root的前驱节点后，需要回到root节点进行访问，然后再到root的右儿子进行访问。于是我们可以每次访问到一棵子树时，找到它的前驱节点，把前驱节点的右儿子变为当前的根节点root，这样当遍历完前驱节点后，可以顺着这个右儿子回到根节点root。但问题是修改了该前驱节点的右儿子后什么时候再改回来呢？  </p>
<ul>
<li>当第一次访问以root为根的子树时，找到它的前驱pre，此时pre的右儿子必定为空，于是把这个右儿子设置为root，以便以后根据这个指针回到root节点。</li>
<li>当第二次回到以root为根的子树时，再找到它的前驱pre，此时pre的右儿子已经被设置成了当前的root，这时把该右儿子重新设置成NULL，然后继续进行root的右儿子的遍历。于是完成了指针的修改。</li>
</ul>
<p>在这样的情景下，寻找当前节点的前驱节点时，不仅需要判断其是否有右儿子，而且还要判断右儿子是否为当前的root节点，跟普通情况下的寻址前驱节点稍微多了一个条件。由于在每次遍历一个节点的时候都需要寻找其前驱节点，而寻找前驱节点的时间一般与树的高度相关，这样看上去算法的复杂度应该为O(nlogn)才对。但由于其只需要对有左儿子的节点才寻找前驱，于是所有寻找前驱时走过的路加起来至多为一棵树的节点数，例如在下文的例子中，只需要对以下节点寻找前驱：</p>
<pre><code>         4
       /   \
      2     6
     / \   / \
    1   3 5   7
</code></pre>
<ul>
<li>节点4：寻找路径为：2-3</li>
<li>节点2：寻找路径为：1</li>
<li>节点6：寻找路径为：5</li>
</ul>
<p>于是寻找前驱加上遍历的运算量之和至多为2*n，n为节点个数，于是算法的复杂度为仍然为O(n)。</p>
<pre><code>    void inOrder3(TreeNode *root)  &#123;
        if(root == NULL) &#123;
            return;
        &#125;
        TreeNode *pNode = root;
        while(pNode) &#123;
            if(pNode-&gt;left == NULL) &#123;
                cout &lt;&lt; pNode-&gt;val &lt;&lt; endl;
                pNode = pNode-&gt;right;
            &#125; else &#123;
                TreeNode *pPre = pNode-&gt;left;
                while(pPre-&gt;right != NULL &amp;&amp; pPre-&gt;right != pNode) &#123;
                    pPre = pPre-&gt;right;
                &#125;
                
                if(pPre-&gt;right == NULL) &#123;
                    pPre-&gt;right = pNode;
                    pNode = pNode-&gt;left;
                &#125; else &#123;
                    pPre-&gt;right = NULL;
                    cout &lt;&lt; pNode-&gt;val &lt;&lt; endl;
                    pNode = pNode-&gt;right; 
                &#125; 
            &#125;
        &#125;
    &#125;
</code></pre>
<h4 id="前序遍历-2"><a href="#前序遍历-2" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>前序遍历和中序遍历类似，只是在遍历过程中访问节点的顺序稍有不同。即在第一次访问一棵子树时，就要先对根节点进行访问，于是cout输出语句被放到了if判断中第一次访问的分支中。</p>
<pre><code>    void preOrder3(TreeNode *root)  &#123;
        if(root == NULL) &#123;
            return;
        &#125;
        TreeNode *pNode = root;
        while(pNode) &#123;
            if(pNode-&gt;left == NULL) &#123;
                cout &lt;&lt; pNode-&gt;val &lt;&lt; endl;
                pNode = pNode-&gt;right;
            &#125; else &#123;
                TreeNode *pPre = pNode-&gt;left;
                while(pPre-&gt;right &amp;&amp; pPre-&gt;right != pNode) &#123;
                    pPre = pPre-&gt;right;
                &#125;
                
                if(pPre-&gt;right == NULL) &#123;
                    pPre-&gt;right = pNode;
                    cout &lt;&lt; pNode-&gt;val &lt;&lt; endl;		//先输出左结点 
                    pNode = pNode-&gt;left;
                &#125; else &#123;
                    pPre-&gt;right = NULL;
                    pNode = pNode-&gt;right; 
                &#125; 
            &#125;
        &#125;
    &#125;
</code></pre>
<h4 id="后序遍历-2"><a href="#后序遍历-2" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>后序遍历稍微复杂，但其遍历的基本顺序也是和前&#x2F;中序遍历类似，只是在打印的时候做了一个翻转。考虑下文例子中的后序遍历结果：1 3 2 5 7 6 4。其可以这样进行拆分并进行解释：</p>
<pre><code>         4
       /   \
      2     6
     / \   / \
    1   3 5   7
</code></pre>
<ul>
<li>1：最左下角的结果节点</li>
<li>3 2：节点2、3的倒序</li>
<li>5：右儿子的最左下角的节点</li>
<li>7 6 4：右边一列节点4、6、7的倒序</li>
</ul>
<p>于是我们可以在中序遍历过程中，当第二次访问到一个节点时，把它的左儿子到它的前驱节点的路径上的节点进行翻转打印，即可得到后序遍历的结果。但这样的话根节点到最右下角那一列会访问不到，增加一个辅助节点作为新的根节点，把原有根节点作为其左儿子即可。</p>
<pre><code>    void reverse(TreeNode *p1, TreeNode *p2) &#123;
        if(p1 == p2) 
            return;
        TreeNode *x = p1; 
        TreeNode *y = p1-&gt;right;
        while(true) &#123;
            TreeNode *temp = y-&gt;right;
            y-&gt;right = x;
            x = y;
            y = temp;
            if(x == p2) 
                break;
        &#125;   
    &#125;

    void printReverse(TreeNode *p1, TreeNode *p2) &#123;
        reverse(p1, p2);
        TreeNode *pNode = p2; 
        while(true) &#123;
            cout &lt;&lt; pNode-&gt;val &lt;&lt; endl;
            if(pNode == p1) 
                break;
            pNode = pNode-&gt;right;
        &#125;   
        reverse(p2, p1);
    &#125;
    
    void postOrder3(TreeNode *root) &#123;
        if(root == NULL) &#123;
            return;
        &#125;
        TreeNode *dummy = new TreeNode(-1);
        dummy-&gt;left = root;
        TreeNode *pNode = dummy;
        while(pNode) &#123;
            if(pNode-&gt;left == NULL)
                pNode = pNode-&gt;right;
            else &#123;
                TreeNode *pPrev = pNode-&gt;left;
                while(pPrev-&gt;right &amp;&amp; pPrev-&gt;right != pNode)&#123;
                    pPrev = pPrev-&gt;right;
                &#125;
                if(pPrev-&gt;right == NULL) &#123;
                    pPrev-&gt;right = pNode;
                    pNode = pNode-&gt;left;
                &#125;
                else &#123;
                    printReverse(pNode-&gt;left, pPrev);
                    pPrev-&gt;right = NULL;
                    pNode = pNode-&gt;right;
                &#125;
            &#125;
        &#125;
    &#125;
</code></pre>
<h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><p>我们对以下简单的二叉树进行测试。</p>
<pre><code>         4
       /   \
      2     6
     / \   / \
    1   3 5   7  
</code></pre>
<p>测试代码</p>
<pre><code>int main() &#123;
    TreeNode a1(1), a3(3), a5(5), a7(7);
    TreeNode a2(2, &amp;a1, &amp;a3), a6(6, &amp;a5, &amp;a7);
    TreeNode a4(4, &amp;a2, &amp;a6);
    
    //前序遍历：4 2 1 3 6 5 7 5 
    preOrder(&amp;a4);
    preOrder2(&amp;a4);
    preOrder3(&amp;a4);
    cout &lt;&lt; endl; 
    
    //中序遍历：1 2 3 4 5 6 7
    inOrder(&amp;a4);
    inOrder2(&amp;a4);
    inOrder3(&amp;a4);
    cout &lt;&lt; endl; 
    
    //后序遍历：1 3 2 5 7 6 4
    postOrder(&amp;a4);
    postOrder2(&amp;a4);
    postOrder3(&amp;a4);
&#125;
</code></pre>
<p>参考链接：<br>&amp;emsp;&amp;emsp;<a href="http://baike.baidu.com/view/549587.htm">二叉树遍历</a><br>&amp;emsp;&amp;emsp;<a href="http://noalgo.info/832.html">二叉树遍历（递归、非递归、Morris遍历）</a><br>&amp;emsp;&amp;emsp;<a href="http://www.wengweitao.com/er-cha-shu-de-san-chong-bian-li-fang-shi-di-gui-fei-di-gui-he-morrisbian-li.html">二叉树的三种遍历方式</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>关于电影下载和广告屏蔽的那点事儿</title>
    <url>/2016/01/24/%E5%85%B3%E4%BA%8E%E7%94%B5%E5%BD%B1%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<p>&amp;emsp;&amp;emsp;我是处女座，有点轻微强迫症和完美主义，所以下电影什么的一般只下高清(蓝光720P起)，看到网上的各种广告也有点不爽，平常喜欢折腾，分享点自己的技巧吧。</p>
<span id="more"></span>
<p> &amp;emsp;&amp;emsp;先说下载电影，除了去电影院，网上看的电影一般都是下载720P的蓝光版，特别喜欢的会看蓝光原盘。那种电影刚上就能下载到的枪版更不会考虑，也不太推荐，画质堪忧。<br> &amp;emsp;&amp;emsp;在这里先简单的补充下网上高清电影的制作流程吧，一般是正规厂家发布了蓝光盘，然后一些高清论坛（SPARG、WiKi等）会进行无损发布（就是原盘，一半在30G<del>50G），然后各大论坛会进行压制，压制成1080P(一半在10G</del>15G)的或者720P(一般在5G左右)的，注意这时候电影都是没有双语字幕的，如果原盘是国内发行版的话里面会有一条国语字幕，但效果一般，在这之后各个字幕组再在此基础上进行进一步的压制、添加特效字幕和音轨等，完了再各自发布，字幕组做的字幕比原盘里封装的效果会好很多，每家字幕组也都会有自己的字幕风格，推荐看的时候使用这种字幕。<br> &amp;emsp;&amp;emsp;接下来说说关于下载方法的问题，可以用迅雷下载种子或者磁力链，如果速度一般的话可以使用百度云直接离线，完了再使用百度管家下载到本地，这种速度也会挺快的。以前百度云没对非会员限速，那会这种方法基本可以达到你网速所允许的最大下载速度，但现在百度对这限速，导致下载的速度多少会受到些影响，并且百度对于一些“你懂的”的资源封的很厉害，对于这种就只能用迅雷了。<br> &amp;emsp;&amp;emsp;给大家推荐几个我经常下电影的网站。<br> &amp;emsp;&amp;emsp;<a href="http://www.cmct.tv/">CMCT</a>：目前网上对电影字幕特效处理的比较好的字幕组，会压制自己的1080P和720P版本，但这是邀请注册，并且没有自己的发布站点，下载他们家的电影必须去论坛下载。<br> &amp;emsp;&amp;emsp;<a href="http://www.cnscg.org/">圣城影视</a>：圣城家园的发布页，这算大名鼎鼎的字幕组了，美剧和电影都做，其实cmct也是早期从圣城分出去的，但现在圣城的更新速度没有cmct的块，但好在质量有保证，字幕是蓝白风格的，看着也舒服。一般建议在上面两个网站下载720P的MKV了，如果你懒得去这些网站找，你可以直接百度电影名字+cmct或者cnscg，然后下载种子业可以。<br> &amp;emsp;&amp;emsp;<a href="http://www.mp4ba.com/">高清MP4吧</a>：更新速度很快，并且枪版、高清版都会发，下载的时候注意下载后缀里有BD的，这代表蓝光压制的，字幕特效做的不错，但很多都是copy别的字幕组然后处理一下特效，不是原创的，最大的优点就是更新速度快。<br> &amp;emsp;&amp;emsp;<a href="http://www.xiaopian.com/">小调网</a>、<a href="http://www.dygod.net/">电影天堂</a>： 这两网站算小水管的福利，电影大小一般都不超过2G，字幕特效不错，更新速度快，如果手机或者平板看的话可以从这里下载。<br> &amp;emsp;&amp;emsp;最后说下关于屏蔽广告的问题，现在浏览器打开网站的效果可以说惨不忍睹，各种广告各种弹窗，建议使用<a href="https://adblockplus.org/">Adblock Plus</a>进行屏蔽，360、火狐和chrome都有对应的插件，使用时可以把默认的拦截规则去除，然后订阅这里的规则：<a href="http://abpchina.org/forum/forum.php?mod=viewthread&tid=29667">Adblock Plus官方规则Easylist China说明与反馈贴</a>，只需要订阅轻量广告过滤规则方案的规则，不建议订阅Easylist，在chrome下订阅easylist的内存占用在100M以上，不订阅easylist规则的内存占用降到了28M左右。需要注意的是上面的方法无法屏蔽视频广告，如果想要屏蔽视频广告的话可以考虑使用<a href="http://ad-safe.com/">Adsafe</a>、<a href="http://www.adbyby.com/">adbyby</a>之类的软件，对视频广告的过滤效果好，我现在使用的屏蔽方法是abp+adbyby。对于重度的谷歌搜索用户需要注意，只有abp能够屏蔽搜索里的推广链接。</p>
]]></content>
      <categories>
        <category>网络资源</category>
      </categories>
      <tags>
        <tag>电影下载， 广告屏蔽</tag>
      </tags>
  </entry>
  <entry>
    <title>关于资源站点的那些事儿</title>
    <url>/2021/08/15/%E5%85%B3%E4%BA%8E%E8%B5%84%E6%BA%90%E7%AB%99%E7%82%B9%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<p>&amp;emsp;&amp;emsp;自己在16年的时候写过一篇类似的<a href="http://wsmmsh.github.io/2016/01/24/%E5%85%B3%E4%BA%8E%E7%94%B5%E5%BD%B1%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF/">文章</a>，但因为5年过去了，很多网站也都已经不复存在了，遂再次更新下，主要围绕电影、美剧、纪录片、电子书等一些大家日常需要的资源，文里提到的网站也都是自己日常在使用的，质量无需担心。  </p>
<span id="more"></span>  
<center>
<img src="/images/微信收款码.png" width="40%" height="40%" />  
</center>

<h6 id="资源收集不易-欢迎打赏"><a href="#资源收集不易-欢迎打赏" class="headerlink" title="资源收集不易 欢迎打赏"></a><center>资源收集不易 欢迎打赏</h6><p><marquee direction=right scrollamount=5><p style="color: #FF0000;font-size:20px;font-weight:bold;face=Microsoft YaHei;">&amp;emsp;&amp;emsp; 请大家有条件的一定要多多支持正版！！！</p></marquee></p>
<h3 id="电影-amp-美剧下载站"><a href="#电影-amp-美剧下载站" class="headerlink" title="电影&amp;美剧下载站"></a>电影&amp;美剧下载站</h3><p>&amp;emsp;&amp;emsp;本节主要介绍一些电影、美剧的下载站，因为随着现在国家版权保护力度的加强，此类的网站也越来越少，大家切用且珍惜吧。下载的话还是推荐使用迅雷（Windows、MacOS、安卓和iOS的客户端都有），如果提示因版权等原因无法下载的话建议换个资源下载，如果因尺度太大的话可以考虑其他BT下载软件。<br>&amp;emsp;&amp;emsp;首先介绍下我们经常在网上能看到的视频资源分类和分辨率。</p>
<blockquote>
<ul>
<li><p><strong>枪版</strong>：一般电影首先在院线上映，此时可能流出的资源就是枪版，资源名字里会带有<em>TC</em>、<em>CAM</em>或<em>TS</em>等，强烈不推荐观看此类资源，毫无质量可言。  </p>
</li>
<li><p><strong>WEB-DL版本</strong>、<strong>HD版</strong>：电影在院线上映一段时间后，各大视频网站也都会上映，此时流出的资源是WEB-DL版本（Web Download），严格来说其并不是一种影片格式，而是用来标识影片来源、品质的标记，其来源主要是国外的iTunes , Netflix等和国内的优酷、爱奇艺、腾讯视频等，品质要比HDTV好，相比HDTV，无水印，无台标logo，无插播广告，无任何剪切，但画面品质仍然达不到BD的水平；同期还会流出HD版（HDTV），是High Definition Television的简称，翻译成中文是“高清晰度电视”的意思，画面质量会比BD稍差，主要表现为亮度不足、色彩不够自然、不够鲜艳等。  </p>
</li>
<li><p><strong>BD版</strong>:视频网站上线一段时间后就会出蓝光盘，此时随之流出的资源就是通过蓝光片源录制的BD版（Bluray Disc），缩写为BD，画面品质比HD和WEB-DL要好，也是我们<strong>首推</strong>的观看类型。  </p>
</li>
<li><p><strong>分辨率</strong>：420P分辨率有效显示格式为720*480；720P分辨率有效显示格式为1280×720；1080P分辨率有效显示格式为：1920×1080；4k分辨率有效显示格式为：4096×2160（属于超高清分辨率,在此分辨率下，观众将可以看清画面中的每一个细节、每一个特写，我的真没有在暗示些什么)。我们选择的分辨率标准肯定是<strong>越高越好</strong>。</p>
</li>
</ul>
</blockquote>
<p>&amp;emsp;&amp;emsp;针对BD版的资源再详细说下,一般是正规厂家发布了蓝光原盘，一些高清论坛会进行无损发布（文件大小一半在30G以上），然后各大资源论坛会对原盘进行压制，压制成1080P(一般在10G左右)或者720P(一般在5G左右)的资源，注意这时候电影都是没有双语字幕的（如果原盘是国内发行版的话里面会有一条国语字幕，但效果一般），在这之后各个字幕组再在此基础上进行进一步的压制、添加特效字幕和音轨等，完了在各自的发布途径里发布，字幕组做的字幕比原盘里封装的效果会好很多，每家字幕组也都会有自己的字幕风格，强烈推荐看的时候使用字幕组的字幕。<br>&amp;emsp;&amp;emsp;推荐一些我经常使用的资源站点吧，按照先后顺序推荐。  </p>
<ul>
<li><h4 id="BT之家"><a href="#BT之家" class="headerlink" title="BT之家"></a><strong>BT之家</strong></h4><p>&amp;emsp;&amp;emsp;特别特别老牌的资源站点了，我去看了下论坛里的帖子，最早的帖子都是2004年发的了。它家不做字幕压制，只做资源分享，大家有需要的资源直接在论坛里搜索就行，然后会有各个字幕组、论坛制作的资源，另外每个资源贴里都有截图，可以稍加筛选，大家选一个自己喜欢的清楚的下载就行（<em>如果是老资源的话推荐CMCT、CNSCG、wofei、mp4ba、CNXP等家的，这些论坛现在差不多都被干掉了，新资源基本上不发了</em>）。<br>&amp;emsp;&amp;emsp;基本上它家任何资源都能搜索得到，有删减的无删减的等等，唯一的一个缺点是网址经常换，为此它家自己都出了一个地址共享软件，可以通过这个小软件找到论坛最新的可访问地址。  </p>
<h6 id="网址1-amp-emsp-amp-emsp-网址2"><a href="#网址1-amp-emsp-amp-emsp-网址2" class="headerlink" title="网址1&amp;emsp;&amp;emsp;网址2"></a><a href="https://www.btbtt15.com/">网址1</a>&amp;emsp;&amp;emsp;<a href="https://btbtt15.com/">网址2</a></h6><h6 id="BT之家专用网址查询工具1-amp-emsp-amp-emsp-BT之家专用网址查询工具2"><a href="#BT之家专用网址查询工具1-amp-emsp-amp-emsp-BT之家专用网址查询工具2" class="headerlink" title="BT之家专用网址查询工具1&amp;emsp;&amp;emsp;BT之家专用网址查询工具2"></a><a href="https://share.weiyun.com/czEqm3CW">BT之家专用网址查询工具1</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EXDXbMW3LKBKvvknHVo2tmYBvjOxSq7WodK5TzC0oLfwbA?e=mzehCN">BT之家专用网址查询工具2</a></h6></li>
<li><h4 id="电影天堂"><a href="#电影天堂" class="headerlink" title="电影天堂"></a><strong>电影天堂</strong></h4><p>&amp;emsp;&amp;emsp;在16年的文章里我就推荐了它家，也是生命力很强的一家网站，它家自己会压制资源，文件都不大，小水管的福音。如果仅仅是手机或者一些不是想收藏的资源也可以从它家下载。另外它家还有很多分店，dygod、dy2018、ygdy、xiaopian等都属于它家的分店。  </p>
<h6 id="网址1-amp-emsp-amp-emsp-网址2-1"><a href="#网址1-amp-emsp-amp-emsp-网址2-1" class="headerlink" title="网址1&amp;emsp;&amp;emsp;网址2"></a><a href="https://www.dy2018.com/">网址1</a>&amp;emsp;&amp;emsp;<a href="https://www.ygdy8.com/">网址2</a></h6></li>
<li><h4 id="梦幻天堂·龙网"><a href="#梦幻天堂·龙网" class="headerlink" title="梦幻天堂·龙网"></a><strong>梦幻天堂·龙网</strong></h4><p>&amp;emsp;&amp;emsp;跟CNSCG、CMCT基本上属于同期的老牌资源论坛，没想到一直留存到了现在，以前发布的资源有着标志性的蓝字白框字幕，现在好像没有这种特色了。就冲今年还在用最新的美版高码原盘压制<a href="http://longwangbt.com/show.php?hash=ee6ef2bcb3fd0b02849878df73619f9a94ff45ce">《色戒》</a>也得支持他家不是？冲冲冲！</p>
<h6 id="资源发布页-amp-emsp-amp-emsp-论坛"><a href="#资源发布页-amp-emsp-amp-emsp-论坛" class="headerlink" title="资源发布页&amp;emsp;&amp;emsp;论坛"></a><a href="http://www.longwangbt.com/">资源发布页</a>&amp;emsp;&amp;emsp;<a href="http://lwgod.org/">论坛</a></h6></li>
<li><h4 id="UUMP4"><a href="#UUMP4" class="headerlink" title="UUMP4"></a><strong><a href="https://www.uump4.net/">UUMP4</a></strong></h4><p>&amp;emsp;&amp;emsp;它家既自己压制资源（文件名后缀里有UUMP4，MP4格式），也做资源转载，推荐看他家自己压制的MP4格式的资源。  </p>
</li>
<li><h4 id="钛影视"><a href="#钛影视" class="headerlink" title="钛影视"></a><strong><a href="http://www.taiyingshi.vip/">钛影视</a></strong></h4><p>&amp;emsp;&amp;emsp;可以作为BT之家的补充，也是汇集各家资源，缺点是搜索出资源后都是一条条的，没有详情介绍页，不像BT之家可以看到截图和剧情资源介绍。</p>
</li>
</ul>
<h3 id="福利站"><a href="#福利站" class="headerlink" title="福利站"></a>福利站</h3><p>&amp;emsp;&amp;emsp;本节主要介绍两个福利网站。  </p>
<ul>
<li><h4 id="小草"><a href="#小草" class="headerlink" title="小草"></a><strong>小草</strong></h4><p>&amp;emsp;&amp;emsp;1024永远的神。  </p>
<h6 id="免翻地址-amp-emsp-amp-emsp-永久地址-amp-emsp-amp-emsp-安卓客户端-amp-emsp-amp-emsp-iOS客户端-amp-emsp-amp-emsp-电脑端地址更新器"><a href="#免翻地址-amp-emsp-amp-emsp-永久地址-amp-emsp-amp-emsp-安卓客户端-amp-emsp-amp-emsp-iOS客户端-amp-emsp-amp-emsp-电脑端地址更新器" class="headerlink" title="免翻地址&amp;emsp;&amp;emsp; 永久地址&amp;emsp;&amp;emsp; 安卓客户端&amp;emsp;&amp;emsp; iOS客户端 &amp;emsp;&amp;emsp; 电脑端地址更新器"></a><a href="https://cl.797z.xyz/index.php">免翻地址</a>&amp;emsp;&amp;emsp; <a href="https://t66y.com/">永久地址</a>&amp;emsp;&amp;emsp; <a href="https://github.com/yuuwill/1024app-android">安卓客户端</a>&amp;emsp;&amp;emsp; <a href="https://github.com/yuuwill/1024app-android">iOS客户端</a> &amp;emsp;&amp;emsp; <a href="https://github.com/yuuwill/1024app-uwp">电脑端地址更新器</a></h6></li>
<li><h4 id="福利吧"><a href="#福利吧" class="headerlink" title="福利吧"></a><strong><a href="https://fuliba2021.net/">福利吧</a></strong></h4><p>&amp;emsp;&amp;emsp;有点文艺清新的福利站。</p>
</li>
</ul>
<h3 id="软件站"><a href="#软件站" class="headerlink" title="软件站"></a>软件站</h3><p>&amp;emsp;&amp;emsp;本节主要介绍几个自己常用的软件破解网站。大家如果有条件请多多支持正版！！！  </p>
<ul>
<li><h4 id="App热"><a href="#App热" class="headerlink" title="App热"></a><strong><a href="https://apphot.cc/">App热</a></strong></h4><p>&amp;emsp;&amp;emsp;烈火的软件站。之前认识他是因为他做的WinRAR很好用，没广告还稳定，然后找到了他之前的软件站心海e站，后来心海e站废掉了，都是广告。现在他开了新站App热，里面的软件大部都是破解版的，大家在使用的时候优先选择直接输入注册码的版本。  </p>
</li>
<li><h4 id="423Down"><a href="#423Down" class="headerlink" title="423Down"></a><strong><a href="https://www.423down.com/">423Down</a></strong></h4><p>&amp;emsp;&amp;emsp;站长就是之前有名的zdfans。下面是网站的介绍：<code>「423Down」是一家由个人运营的软件下载站博客，专注去广告类软件输出10年，主要提供电脑软件和安卓软件及系统镜像下载，更新资源速度快，致力于打造个人IP品牌。「zd423」是站长本人最早使用过的网络ID马甲，个人曾经在2013年创建了下载站「zdfans.com」软件分享平台领跑者，原域名是在2016年被网络公司收购商业化运营，目前已经是搜索引擎流量非常大的软件下载站，现在个人IP网址为「423down.com」始于爱好，忠于习惯，不忘初心，方能长久坚持！</code></p>
</li>
</ul>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p>(1)<a href="https://zhuanlan.zhihu.com/p/261938045">赶紧收藏了！最全的电影格式介绍来了！</a><br>(2)<a href="https://www.jianshu.com/p/6c6e1cd1d4aa">关于电影资源画质和一些视频格式的解析</a><br>(3)<a href="http://www.360doc.com/content/19/1212/09/27515762_879215614.shtml">文字特效代码集中营</a> </p>
]]></content>
      <categories>
        <category>网络资源</category>
      </categories>
  </entry>
  <entry>
    <title>我看过的那些书（计算机方面）</title>
    <url>/2016/05/11/%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E4%B9%A6%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%B9%E9%9D%A2%EF%BC%89/</url>
    <content><![CDATA[<p>记录自己读过的计算机方面的书籍，鉴于水平有限，各种书的简介只是自己的感受，详细的还需要参考网上的其他资料。  </p>
<span id="more"></span>

<h2 id="1、C-Primer-中文版（第-5-版）"><a href="#1、C-Primer-中文版（第-5-版）" class="headerlink" title="1、C++ Primer 中文版（第 5 版）"></a>1、C++ Primer 中文版（第 5 版）</h2><p><img src="https://z3.ax1x.com/2021/06/29/RdKJk6.jpg" alt="C++ Primer 中文版（第 5 版）"></p>
<p><a href="http://item.jd.com/11306138.html">介绍</a><br>简介：C++的工具书，介绍的很全，字典类图书，不适合精读。</p>
<h2 id="2、PHP和MySQL-Web开发（原书第4版）"><a href="#2、PHP和MySQL-Web开发（原书第4版）" class="headerlink" title="2、PHP和MySQL Web开发（原书第4版）"></a>2、PHP和MySQL Web开发（原书第4版）</h2><p><img src="https://z3.ax1x.com/2021/06/29/RdKtfO.jpg" alt="PHP和MySQL Web开发（原书第4版）"></p>
<p><a href="http://item.jd.com/10059047.html">介绍</a><br>简介：PHP入门的好书，开始第一次读的是英文版的，后来有问题回看的时候看的中文，实在是没有体会到网上说的看原版书的好处，感觉还是中文的读的踏实。</p>
<h2 id="3、细说PHP-精要版"><a href="#3、细说PHP-精要版" class="headerlink" title="3、细说PHP(精要版)"></a>3、细说PHP(精要版)</h2><p><img src="https://z3.ax1x.com/2021/06/29/RdKa1e.jpg" alt="细说PHP（精要版）"><br><a href="http://item.jd.com/11241062.html">介绍</a><br>简介：<a href="http://item.jd.com/11113844.html">细说PHP</a>的精简版，重点突出很条理，感觉这本书跟上本提到的PHP和MySQL Web开发任选一本足矣。</p>
<h2 id="4、Ajax、JavaScript和PHP编程导学"><a href="#4、Ajax、JavaScript和PHP编程导学" class="headerlink" title="4、Ajax、JavaScript和PHP编程导学"></a>4、Ajax、JavaScript和PHP编程导学</h2><p><img src="https://z3.ax1x.com/2021/06/29/RdKUpD.jpg" alt="Ajax、JavaScript和PHP编程导学"><br><a href="http://item.jd.com/10687016.html">介绍</a><br>简介：这本书是哈佛大学的公开课<a href="http://cs50.tv/2015/fall/">CS50</a>里提到的一本书，比较简单，简单翻翻就行，如需深入了解还需要查阅有关书籍。  </p>
<h2 id="5、Linux系统命令己Shell脚本实践指南"><a href="#5、Linux系统命令己Shell脚本实践指南" class="headerlink" title="5、Linux系统命令己Shell脚本实践指南"></a>5、Linux系统命令己Shell脚本实践指南</h2><p><img src="https://z3.ax1x.com/2021/06/29/RdK8Tx.jpg" alt="Linux系统命令及Shell脚本实践指南">)<br><a href="http://item.jd.com/11354663.html">介绍</a><br>简介：讲解的挺全面的，觉得学习Linux和shell，感觉还是动手来的快，对着这书撸一遍，应付面试差不多了。其他的深入还需要实践中碰到问题解决问题才能进一步提升吧。</p>
<h2 id="6、数据结构与算法分析-C-描述（第3版）"><a href="#6、数据结构与算法分析-C-描述（第3版）" class="headerlink" title="6、数据结构与算法分析 C++描述（第3版）"></a>6、数据结构与算法分析 C++描述（第3版）</h2><p><img src="https://z3.ax1x.com/2021/06/29/RdKYtK.jpg" alt=" 数据结构与算法分析 C++描述（第3版）"></p>
<p><a href="http://www.bookschina.com/2162032.htm">介绍</a><br>简介：算法的经典书籍，无需解释，这书应该都绝版了，网上现在卖的都是第2版的C语言版，我也是翻了好久才淘到的，但应该差别不大。感觉算法很重要，尤其是在校招的时候，思想！基础！自己在校招之前的这段时间要重点放在这上面。这本书和<a href="https://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O">《算法》</a>要温习一下，然后刷<a href="https://leetcode.com/">LeetCode</a>，提高自己的编程算法能力。 </p>
<h2 id="待看"><a href="#待看" class="headerlink" title="待看"></a>待看</h2><p><a href="https://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O">《算法》</a><br><a href="http://item.jd.com/10360906.html">《深入理解计算机系统》</a></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title>新阶段学习</title>
    <url>/2018/05/28/%E6%96%B0%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>软考考完了，开始自己新的学习历程吧，先mark两门课程。<br>谷歌的<a href="https://developers.google.cn/machine-learning/crash-course">《机器学习速成课程》</a>和吴恩达的<a href="https://developers.google.cn/machine-learning/crash-course">《深度学习工程师》</a></p>
<span id="more"></span>


<p>学习打卡进度：</p>
<h4 id="20180528-Reducing-Loss"><a href="#20180528-Reducing-Loss" class="headerlink" title="20180528 Reducing Loss"></a>20180528 <a href="https://developers.google.cn/machine-learning/crash-course/reducing-loss/video-lecture">Reducing Loss</a></h4><h4 id="20180531-使用TF的基本步骤"><a href="#20180531-使用TF的基本步骤" class="headerlink" title="20180531 使用TF的基本步骤"></a>20180531 <a href="https://developers.google.cn/machine-learning/crash-course/first-steps-with-tensorflow/programming-exercises">使用TF的基本步骤</a></h4><h4 id="20180604-验证-Validation"><a href="#20180604-验证-Validation" class="headerlink" title="20180604 验证 (Validation)"></a>20180604 <a href="https://developers.google.cn/machine-learning/crash-course/validation/video-lecture">验证 (Validation)</a></h4><p>神经网络和深度学习 <a href="http://mooc.study.163.com/learn/2001281002?tid=2001392029#/learn/content?type=detail&id=2001701007">1.5 关于这门课</a></p>
<h4 id="20180611-2-9-logistic中的梯度下降法"><a href="#20180611-2-9-logistic中的梯度下降法" class="headerlink" title="20180611 2.9 logistic中的梯度下降法"></a>20180611 <a href="http://mooc.study.163.com/learn/2001281002?tid=2001392029#/learn/content?type=detail&id=2001702009&cid=2001700037">2.9 logistic中的梯度下降法</a></h4><h4 id="20180612-3-1-神经网络概览"><a href="#20180612-3-1-神经网络概览" class="headerlink" title="20180612 3.1 神经网络概览"></a>20180612 <a href="http://mooc.study.163.com/learn/2001281002?tid=2001392029#/learn/content?type=detail&id=2001701017">3.1 神经网络概览</a></h4><h4 id="20180613-3-9-神经网络的梯度下降法"><a href="#20180613-3-9-神经网络的梯度下降法" class="headerlink" title="20180613 3.9 神经网络的梯度下降法"></a>20180613 <a href="http://mooc.study.163.com/learn/2001281002?tid=2001392029#/learn/content?type=detail&id=2001701020&cid=2001694278">3.9 神经网络的梯度下降法</a></h4><h4 id="20180614-4-6-前向和反向传播"><a href="#20180614-4-6-前向和反向传播" class="headerlink" title="20180614 4.6 前向和反向传播"></a>20180614 <a href="http://mooc.study.163.com/learn/2001281002?tid=2001392029#/learn/content?type=detail&id=2001702025&cid=2001700050">4.6 前向和反向传播</a></h4><h4 id="20180619-神经网络和深度学习学习完毕，打算完成本章编程习题。mark书《Deep-learning》"><a href="#20180619-神经网络和深度学习学习完毕，打算完成本章编程习题。mark书《Deep-learning》" class="headerlink" title="20180619 神经网络和深度学习学习完毕，打算完成本章编程习题。mark书《Deep learning》"></a>20180619 神经网络和深度学习学习完毕，打算完成本章编程习题。mark书<a href="https://github.com/exacity/deeplearningbook-chinese">《Deep learning》</a></h4><h4 id="20180702-练习assignment2-2"><a href="#20180702-练习assignment2-2" class="headerlink" title="20180702 练习assignment2_2"></a>20180702 练习assignment2_2</h4><h4 id="20180705-assignment2-2结束，改善深层神经网络：超参数调试、正则化以及优化1-1结束，后续边看新的边练习旧的。"><a href="#20180705-assignment2-2结束，改善深层神经网络：超参数调试、正则化以及优化1-1结束，后续边看新的边练习旧的。" class="headerlink" title="20180705 assignment2_2结束，改善深层神经网络：超参数调试、正则化以及优化1.1结束，后续边看新的边练习旧的。"></a>20180705 assignment2_2结束，改善深层神经网络：超参数调试、正则化以及优化1.1结束，后续边看新的边练习旧的。</h4><h4 id="20180712-1-4-正则化"><a href="#20180712-1-4-正则化" class="headerlink" title="20180712 1.4 正则化"></a>20180712 <a href="http://mooc.study.163.com/learn/2001281003?tid=2001391036#/learn/content?type=detail&id=2001701043&cid=2001700055">1.4 正则化</a></h4>]]></content>
      <categories>
        <category>自我提升</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>求连续子向量的最大和</title>
    <url>/2016/04/14/%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%90%91%E9%87%8F%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<p>本问题来自于《编程珠玑》第八章。<br>问题：输入是具有n个整数的向量，输出是输入向量的任何连续子向量中的最大和。</p>
<span id="more"></span>
<h3 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p>立方算法，该算法需求出所有子序列的和，时间复杂度为$O(n^3)$。本算法对$max$进行了$n^3&#x2F;2$次调用。</p>
<pre><code>int maxSum1(vector&lt;int&gt; nums) &#123;
    int maxsofar = 0, len = nums.size();
    if(len == 0) &#123;
        return 0;
    &#125; else if(len &gt; 0) &#123;
        for(int i=0; i&lt;len; i++) &#123;
            for(int j=i; j&lt;len; j++) &#123;
                int sum = 0;
                for(int k=i; k&lt;=j; k++) &#123;	
                    sum += nums[k];
                &#125;
                maxsofar = max(maxsofar, sum);	//求出所有子序列的和
            &#125;
        &#125;
        if(maxsofar &gt; 0) &#123;
            return maxsofar;
        &#125; else &#123;
            return 0;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h3><p>算法二都是通过固定的步数而不是算法一的$[j-i+1]$步内完成对$nums[i,j]$的求和，但根据在固定时间内计算总和时使用方法的不同分为了<strong>a、b</strong>两种算法，两者的时间复杂度都为$O(n^2)$。本算法对$max$进行了$n^2&#x2F;2$次调用。<br><strong>a</strong>算法由$nums[i,j]$的总和与前面计算出的总和$nums[i,j-1]$密切相关可得。</p>
<pre><code>int maxSum2a(vector&lt;int&gt; nums) &#123;
    int maxsofar = 0, len = nums.size();
    if(len == 0) &#123;
        return 0;
    &#125; else if(len &gt; 0) &#123;
        for(int i=0; i&lt;len; i++) &#123;
            int sum = 0;
            for(int j=i; j&lt;len; j++) &#123;
                sum += nums[j];
                maxsofar = max(maxsofar, sum);
            &#125;
        &#125;
        if(maxsofar &gt; 0) &#123;
            return maxsofar;				
        &#125; else &#123;
            return 0;
        &#125;
    &#125;
&#125;	
</code></pre>
<p><strong>b</strong>算法是通过访问在循环执行前就已构建的数据结构来计算综合。cumarr中的第i个元素包含$nums[0,i]$中各个数的累加和，所以$nums[i,j]$中各个数的和可由$cumarr[j]-cumarr[i-1]$得到。</p>
<pre><code>int maxSum2b(vector&lt;int&gt; nums) &#123;
    int maxsofar = 0, len = nums.size();
    int cumarr[len];
    if(len == 0) &#123;
        return 0;
    &#125; else if (len &gt; 0) &#123;
        cumarr[-1] = 0;
        for(int i=0; i&lt;len; i++) &#123;
            cumarr[i] = cumarr[i-1] + nums[i];
        &#125;
        for(int i=0; i&lt;len; i++) &#123;
            for(int j=i; j&lt;len; j++) &#123;
                int sum = cumarr[j] - cumarr[i-1];
                maxsofar = max(maxsofar, sum);
            &#125;
        &#125;
        if(maxsofar &gt; 0) &#123;
            return maxsofar;				
        &#125; else &#123;
            return 0;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="算法三"><a href="#算法三" class="headerlink" title="算法三"></a>算法三</h3><p>采用分治算法，将输入向量分为左、右两部分，分别计算左、右半部分的子序列和，再加上横跨左右两部分的最大连续子序列和，最后返回三个和中的最大值，该算法的时间复杂度为$O(nlogn)$。 本算法使用了对数的额外空间，其他算法仅使用了常熟的额外空间。<br><strong>注：</strong>开始的时候以为<code>for</code>循环里只是求出了半截子序列的所有和，并没有对子序列里的任意连续子序列求和，仔细研读书本后，发现了是在<code>return</code>里的<code>maxSum3</code>里实现了递归。</p>
<pre><code>int maxSum3(vector&lt;int&gt; nums, int l, int u) &#123;
    if(l &gt; u) &#123;
        return 0;
    &#125;
    if(l == u) &#123;
        return max(0, nums[1]);
    &#125;
    int m = (l + u) / 2;
    int sum = 0;
    int lmax = sum;
    for(int i=m; i&gt;=1; i--) &#123;
        sum += nums[i];
        lmax = max(lmax, sum);
    &#125;
    sum = 0;
    int rmax = sum;
    for(int j=m+1; j&lt;u; j++) &#123;
        sum += nums[j];
        rmax = max(rmax, sum);
    &#125;
    return (lmax+rmax &gt;= maxSum3(nums, 1, m)) ? (lmax+rmax &gt;= maxSum3(nums, m+1, u) 
    ? lmax+rmax : maxSum3(nums, m+1, u)) 
    : (maxSum3(nums, 1, m) &gt;= maxSum3(nums, m+1, u) 
    ? maxSum3(nums, 1, m) : maxSum3(nums, m+1, u)); 
&#125;
</code></pre>
<h3 id="算法四"><a href="#算法四" class="headerlink" title="算法四"></a>算法四</h3><p>该算法为扫描算法，从数组最左端开始扫描，一直到最右端，记下遇到的子序列的和的最大值。最大和的最大值为0，假设我们已经解决了$nums[0,i-1]$的问题，此处可以采用类似于分治法的思路，前i个元素中，子序列最大和要么在前$i-1$个元素中（我们将其存储在子啊$maxsofar$中），要么在其结束位置i处（我们将其存储在$maxendinghere$中），该算法的时间复杂度为$O(n)$。本算法对$max$进行了$2n$次调用，是实时的，一趟输入完毕它就计算出答案，也别适用于处理磁盘文件。</p>
<pre><code>int maxSum4(vector&lt;int&gt; nums) &#123;
    int maxsofar = 0, maxendinghere = 0, len = nums.size();
    if(len == 0) &#123;
        return 0;
    &#125; else if(len &gt; 0) &#123;
        for(int i=0; i&lt;len; i++) &#123;
            maxendinghere = max(maxendinghere+nums[i], 0);
            maxsofar = max(maxsofar, maxendinghere);
        &#125;
        return maxsofar;
    &#125;
&#125;
</code></pre>
<h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><p><a href="https://github.com/wsmmsh/algorithm/blob/master/%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E6%B1%82%E6%9C%80%E5%A4%A7%E5%92%8C.md">全部代码</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm，编程珠玑</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有趣的资源</title>
    <url>/2021/06/30/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p>&amp;emsp;&amp;emsp;本文记录一些自己看过的或者收集的资源，主要包括电子书、电影等，文件名字若有带超链接的，一般是链接到豆瓣或者资源网站的简介页，资源的质量无需担心，都是经过自己把关的。</p>
<span id="more"></span>  
<center>
<img src="/images/微信收款码.png" width="40%" height="40%" />  
</center>

<h6 id="资源收集不易-欢迎打赏"><a href="#资源收集不易-欢迎打赏" class="headerlink" title="资源收集不易 欢迎打赏"></a><center>资源收集不易 欢迎打赏</h6><h3 id="书"><a href="#书" class="headerlink" title="书"></a>书</h3><ul>
<li><h5 id="《中国近代史》"><a href="#《中国近代史》" class="headerlink" title="《中国近代史》"></a><strong>《中国近代史》</strong></h5>&amp;emsp;&amp;emsp;徐中约的代表作，自己也看过，是港版的无删减版。epub格式。<br><a href="/download/%E4%B8%AD%E5%9B%BD%E8%BF%91%E4%BB%A3%E5%8F%B2%EF%BC%88%E5%BE%90%E4%B8%AD%E7%BA%A6%E6%B8%AF%E7%89%88%EF%BC%89.epub">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://share.weiyun.com/Bn5YjjF4">下载链接二</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EQ1Wjn9tN51BvysxLYaADCQBVW-Z5jD2PZdPrSTVe2Fy6A?e=QjlvZ5">下载链接三</a>  </li>
<li><h5 id="《经济学讲义》"><a href="#《经济学讲义》" class="headerlink" title="《经济学讲义》"></a><strong><a href="https://book.douban.com/subject/30280804/">《经济学讲义》</a></strong></h5>&amp;emsp;&amp;emsp;薛兆丰的经济学讲义。epub格式。<br> <a href="https://share.weiyun.com/VYN8P2lv">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/ERVqDUyMFElAm7SS9spQCU0BlQiMdx-s4vqMK1YdPRJ5mw?e=MR2qJX">下载链接二</a>  </li>
<li><h5 id="《毛泽东选集》"><a href="#《毛泽东选集》" class="headerlink" title="《毛泽东选集》"></a><strong>《毛泽东选集》</strong></h5>&amp;emsp;&amp;emsp;第一次读毛选，感觉收获颇丰，毛泽东的思想真是永不过时，常看常新。mobi格式。<br> <a href="https://share.weiyun.com/iucGC06U">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/ESjCrY90QKJBreX2met_DuQBNIhNhd9oh6e1kDMQtg-PBw?e=FgZNBd">下载链接二</a>  </li>
<li><h5 id="《生死二十八天》"><a href="#《生死二十八天》" class="headerlink" title="《生死二十八天》"></a><strong><a href="https://book.douban.com/subject/34819201/">《生死二十八天》</a></strong></h5>&amp;emsp;&amp;emsp;感觉国内很少有文献写中越之战经历的，本书是四十一军原纪委书记宋子佩同志在1979年“自卫还击，保卫边疆”对越作战胜利后，以所在部队作战经过为背景撰写的一部战争纪实作品。自己读完了全本，感觉真是感慨非凡，真验了那么一句话“天下虽安，忘战必危”。pdf格式。<br> <a href="https://share.weiyun.com/Khg22Bgv">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:b:/g/personal/14120335_bjtu_edu_cn/ESvLkTziXMVDqDTYKWZYYMABj5Y4hXvJLBhj1OWmEfuHIA?e=Do7eC4">下载链接二</a>  </li>
<li><h5 id="《皇权与绅权》"><a href="#《皇权与绅权》" class="headerlink" title="《皇权与绅权》"></a><strong><a href="https://book.douban.com/subject/33423602/">《皇权与绅权》</a></strong></h5>&amp;emsp;&amp;emsp;费老很经典的一本书，自己其实是因为找不到别的电子版本，才找到这本竖版书看的，书本身很不错，写的很多东西对于当下仍有较强的借鉴意义。pdf格式。<br> <a href="https://share.weiyun.com/kKoGLUl7">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:b:/g/personal/14120335_bjtu_edu_cn/ESGlc41kWZdKtoE43ngR1LABMawqtdgEeP0LJm52aXTAxg?e=dYs8XO">下载链接二</a>  </li>
<li><h5 id="《爆发-大数据时代预见未来的新思维》"><a href="#《爆发-大数据时代预见未来的新思维》" class="headerlink" title="《爆发 : 大数据时代预见未来的新思维》"></a><strong><a href="https://book.douban.com/subject/10769712/">《爆发 : 大数据时代预见未来的新思维》</a></strong></h5>&amp;emsp;&amp;emsp;对于大数据思维很好的启蒙，也是自己看的最快的一本书了。mobi格式。<br> <a href="https://share.weiyun.com/QLnR7mI0">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EVHYC0pm_1BIiqDQzyj9u2sBaWxHtKsi5TE21A8-GwPfRg?e=P12S3h">下载链接二</a>  </li>
<li><h5 id="《把自己作为方法》"><a href="#《把自己作为方法》" class="headerlink" title="《把自己作为方法》"></a><strong><a href="https://book.douban.com/subject/35092383/">《把自己作为方法》</a></strong></h5>&amp;emsp;&amp;emsp;自己读过的为数不多的对于当下社会现象一些深入思考。对于大数据思维很好的启蒙，也是自己看的最快的一本书了。epub格式。<br> <a href="https://share.weiyun.com/70fxeto0">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EfCCHt6w_ytKnnZvqPge1SIBbOQFSVwaHKvL3F4Z1wUErQ?e=aSBRbD">下载链接二</a>    </li>
<li><h5 id="《目标》"><a href="#《目标》" class="headerlink" title="《目标》"></a><strong><a href="https://book.douban.com/subject/1464593/">《目标》</a></strong></h5>&amp;emsp;&amp;emsp;经典的管理类书籍，对于如果提升工作中各个环节直接的衔接效率具有很好的参考意义。pdf格式。<br> <a href="https://share.weiyun.com/xa5XYrEA">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:b:/g/personal/14120335_bjtu_edu_cn/EadL1fDb_XxOmqrNaRiOD78BNQBvHuVT29HmY1Ty7k-4FQ?e=bCELqD">下载链接二</a>           </li>
<li><h5 id="《枪炮、病菌与钢铁》"><a href="#《枪炮、病菌与钢铁》" class="headerlink" title="《枪炮、病菌与钢铁》"></a><strong><a href="https://book.douban.com/subject/26743265/">《枪炮、病菌与钢铁》</a></strong></h5>&amp;emsp;&amp;emsp;病菌对于人类的摧毁力远胜于枪炮，钢铁带来的生产力的提高也会促进人类中生产力较高的族群对于低生产力族群的碾压。epub格式。<br> <a href="https://share.weiyun.com/EfQRZ5CK">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/ERLTTDNiIMBLsLKMTkiR4KABZtEMnduB_JIdj6LRPKCsYQ?e=H8Iua7">下载链接二</a>          </li>
<li><h5 id="《筚路蓝缕：世纪工程决策建设记述》"><a href="#《筚路蓝缕：世纪工程决策建设记述》" class="headerlink" title="《筚路蓝缕：世纪工程决策建设记述》"></a><strong><a href="https://book.douban.com/subject/30348776/">《筚路蓝缕：世纪工程决策建设记述》</a></strong></h5>&amp;emsp;&amp;emsp;本书作者张国宝先后在国家计划委员会、国家发展计划委员会、国家发展和改革委员会、国家能源局工作，亲历了一些被称为世纪工程的重大工程项目的决策建设情况，反映了党中央国务院高瞻远瞩谋划和科学民主决策这些项目的过程，也让自己管中窥豹似的了解下近些年来的一些国家级大工程（如西气东输、西电东送、青藏铁路、上海洋山深水港、首都机场扩建、杭州湾跨海大桥、中俄原油管道工程、中亚天然气管道、中缅油气管道、湛江钢铁工业基地、特高压输变电、金沙江水电开发等一大批世纪工程以及建设全国互联互通的统一大电网、城市轨道交通、天然气事业、新能源、船舶、汽车、钢铁、装备制造业等）的发展规划和政策的决策论证建设过程及思考决策过程。结合自己毕业近4年来的工作，对于这种感受更是愈加深刻。一直没有找到本地下载的，提供一个咪咕的免费在线阅读链接吧。<br> <a href="https://wap.cmread.com/r/p/catalog.jsp?ln=31_478307_97695029_17_1_l1l14l14l5&ms=lq6cjx&ms=lq6cjx&vt=3&vt=3&bid=486873939">在线阅读</a>  </li>
<li><h5 id="《共同基金常识》"><a href="#《共同基金常识》" class="headerlink" title="《共同基金常识》"></a><strong><a href="https://book.douban.com/subject/27153416/">《共同基金常识》</a></strong></h5>&amp;emsp;&amp;emsp;据说是蛮经典的基金类书籍。epub格式。<br> <a href="https://share.weiyun.com/E1qLi2YK">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EQ_TpcNpq1lAkGBbo_FDFNcB1zfL73HB8BbVEi8Mp6DI9A?e=M2bQQ4">下载链接二</a>  </li>
<li><h5 id="《漫步华尔街》"><a href="#《漫步华尔街》" class="headerlink" title="《漫步华尔街》"></a><strong><a href="https://book.douban.com/subject/27596775/">《漫步华尔街》</a></strong></h5>&amp;emsp;&amp;emsp;第11版，书中没有任何夸夸其谈的投资技巧，只有一个历经时间检验、以全面研究为基础的投资策略。epub格式。<br> <a href="https://share.weiyun.com/rrsXFkgm">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/Ec3xI8cMeSdEnvopozaXeIsBk1lYELwG4-SG89-DCcPMog?e=VdVmNg">下载链接二</a>  </li>
<li><h5 id="《大数据时代》"><a href="#《大数据时代》" class="headerlink" title="《大数据时代》"></a><strong><a href="https://book.douban.com/subject/20429677/">《大数据时代》</a></strong></h5>&amp;emsp;&amp;emsp;本书认为大数据的核心就是预测。大数据将为人类的生活创造前所未有的可量化的维度。大数据已经成为了新发明和新服务的源泉，而更多的改变正蓄势待发。书中展示了谷歌、微软、亚马逊、IBM、苹果、facebook、twitter、VISA等大数据先锋们最具价值的应用案例。epub格式。<br> <a href="https://share.weiyun.com/J0LCrr2P">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/ERmV5QKMKX1Bsn3eX8VCx18B88GwemPfiEDRVXeKU_QdYw?e=WCwQLh">下载链接二</a>  </li>
<li><h5 id="《围城》"><a href="#《围城》" class="headerlink" title="《围城》"></a><strong><a href="https://book.douban.com/subject/1855364/">《围城》</a></strong></h5>&amp;emsp;&amp;emsp;自己看了无数次总算看完的书了。epub格式。<br> <a href="https://share.weiyun.com/3RX7pWx5">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EbbFn5Q99PxLtUaPtBgaABEBtEsc8v9Mrw_tCq9uZSnHbg?e=0Zza2N">下载链接二</a>  </li>
<li><h5 id="《你当像鸟飞往你的山》"><a href="#《你当像鸟飞往你的山》" class="headerlink" title="《你当像鸟飞往你的山》"></a><strong><a href="https://book.douban.com/subject/33440205/">《你当像鸟飞往你的山》</a></strong></h5>&amp;emsp;&amp;emsp;作者的成长经历很特殊，可以算得上很差了，甚至连学都没上过，父亲成天为世界末日做准备，母亲完全依附于父亲，最终作者从一个十七岁前从未踏入教室的大山女孩化身为哈佛大学、剑桥大学、哲学硕士，历史博士……教育可以带给我们一个崭新的世界，为生命带来无限可能。epub格式。<br> <a href="https://share.weiyun.com/G3vLP9Rm">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:b:/g/personal/14120335_bjtu_edu_cn/EYwIgKgccyJBmTibZkc2P-UBRw-_8LrAKkjIj4jgDDCCpQ?e=Gm4HNo">下载链接二</a>  </li>
<li><h5 id="《中国人行动的逻辑》"><a href="#《中国人行动的逻辑》" class="headerlink" title="《中国人行动的逻辑》"></a><strong><a href="https://book.douban.com/subject/27169691/">《中国人行动的逻辑》</a></strong></h5>&amp;emsp;&amp;emsp;本书根植于中国本土视角，以社会学、社会心理学和文化人类学等学科为参照系，对中国人的表与里、心理机制与行动逻辑，及所处的中国社会具体阶段与文化脉络，进行了方法论、概念以及经验和理论的探讨。尤其注重对中国人的行动策略同中国社会结构、文化情境之间相互关系的研究，力图从中国人日常而真实、现实而具体的层面上建构起分析中国人社会行动的理论框架。pdf格式。<br> <a href="https://share.weiyun.com/CYB1Dyts">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EW1lFPKBYFZBg1T_bK_U1cwBlkdDa21TNiH7Cj2Rf_-BRQ?e=x6nfY1">下载链接二</a>  </li>
<li><h5 id="《苏东坡传》"><a href="#《苏东坡传》" class="headerlink" title="《苏东坡传》"></a><strong><a href="https://book.douban.com/subject/1792668/">《苏东坡传》</a></strong></h5>&amp;emsp;&amp;emsp;林语堂最得意的作品，中国现代长篇传记开标立范之作。苏东坡是一个无可救药的乐天派、一个伟大的人道主义者、一个百姓的朋友、一个大文豪、大书法家、创新的画家、造酒试验家、一个工程师、一个憎恨清教徒主义的人、一位瑜伽修行者佛教徒、巨儒政治家、一个皇帝的秘书、酒仙、厚道的法官、一位在政治上专唱反调的人。一个月夜徘徊者、一个诗人、一个小丑。但是这还不足以道出苏东坡的全部……苏东坡比中国其他的诗人更具有多面性天才的丰富感、变化感和幽默感，智能优异，心灵却像天真的小孩——这种混合等于耶稣所谓蛇的智慧加上鸽子的温文。epub格式。<br> <a href="https://share.weiyun.com/P1M2T4l6">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EVcVfArpQBpMnFjU7BD3QUkB_v2vPJCFywP--MfeHsFN3w?e=05K3On">下载链接二</a>  </li>
<li><h5 id="《中国神话史》"><a href="#《中国神话史》" class="headerlink" title="《中国神话史》"></a><strong><a href="https://book.douban.com/subject/26665789/">《中国神话史》</a></strong></h5>&amp;emsp;&amp;emsp;自己一直想了解下中国古代整体的神话体系架构，遂读此书。本书是是研究中国神话基础理论的一部开山之作。袁珂先生在数十年整理和研究中国神话的过程中，逐渐认为中国神话的范围要从狭隘的圈子里跳出来，扩大视野，才能见到中国神话的真正丰美。在本书中，他以广义神话思想为基本认识，引经据典，考察了中国神话在流传中的演变，和它对后世文学艺术的影响，以及历代神话整理者、研究者在整理、研究工作中的一些问题，是对中国神话发展形成整体概念的必读经典。epub格式。<br> <a href="https://share.weiyun.com/InXxrAeW">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EYEVib2NrB1DvgQyeKQaDd8BT9WRF0TnxoiG0sAnrS9kIA?e=ghKkWz">下载链接二</a>  </li>
<li><h5 id="《乡土中国》"><a href="#《乡土中国》" class="headerlink" title="《乡土中国》"></a><strong><a href="https://book.douban.com/subject/1795079/">《乡土中国》</a></strong></h5>&amp;emsp;&amp;emsp;费老的经典之作，不必多言。pdf格式。<br> <a href="https://share.weiyun.com/1OKRNOLV">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:b:/g/personal/14120335_bjtu_edu_cn/EVlFVDfguBlCnwPT32oD7XwBewGlWmIbIogEM66W3bOywA?e=4pbqS6">下载链接二</a>  </li>
<li><h5 id="《江城》"><a href="#《江城》" class="headerlink" title="《江城》"></a><strong><a href="https://book.douban.com/subject/7060185/">《江城》</a></strong></h5>&amp;emsp;&amp;emsp;因为自己喜欢的人，对涪陵产生了极大的兴趣，然后读了和平队的何伟（彼得·海斯勒）写的这本书，详细的描述了作者在涪陵支教期间的所见所闻，包括中间还去中国大西北度了一次假的经历。一个外国人，现在看起来很稀松平常，当时却在小城涪陵引发了不小的“震动”。mobi格式。<br> <a href="https://share.weiyun.com/oWnwV1N5">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:f:/g/personal/14120335_bjtu_edu_cn/EmaJRrxRgfRGrFRu3FC8CZYB2RWufmjL3ME35FeIR6_6gw?e=LkJFer">下载链接二</a>  </li>
<li><h5 id="《国家的视角》"><a href="#《国家的视角》" class="headerlink" title="《国家的视角》"></a><strong><a href="https://book.douban.com/subject/5942678/">《国家的视角》</a></strong></h5>&amp;emsp;&amp;emsp;本书作者分析了在各个领域中，由国家主导的大型规划项目遭遇失败的例子。当国家权力坚持推行简单的规划方案，而这种方案对复杂且不易理解之相关性尤显粗暴时，中央主控的社会规划项目就很难取得成功。进而言之，针对社会组织的设计要想获得成功，必须依靠这样一种认知：即地方知识和实践知识与常规知识和技术知识同等重要。作者列举了令人信服的例证，并质疑了“发展理论”，同时反对独裁权力主导的规划项目对国民价值、愿望和目标的忽视。“社会的清晰性提供了大规模开展社会工程的可行性，极端的现代主义意识形态提供了愿望，独裁的国家有实现这一愿望的决定权和行动能力，软弱的公民社会则提供了等级社会作为其实现的基础。”在作者看来，上述四个因素的结合，往往使得悲剧难以避免。pdf格式。<br> <a href="https://share.weiyun.com/xPiMOmWI">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:b:/g/personal/14120335_bjtu_edu_cn/Eb8t-98ksI9BjAvNyj30FKMBMXkt0xA_kcidaJX-m7F2Jg?e=19sHvk">下载链接二</a>  </li>
<li><h5 id="《江湖丛谈》"><a href="#《江湖丛谈》" class="headerlink" title="《江湖丛谈》"></a><strong><a href="https://book.douban.com/subject/4934407/">《江湖丛谈》</a></strong></h5>&amp;emsp;&amp;emsp;个人感觉是一本很经典的江湖科普书籍，为<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%98%94%E5%A6%82/2716667?fr=aladdin">连阔如先生</a>遗著，是我国现今仅存的一部客观而又比较全面地介绍江湖行当、行话和内幕的书籍，以大量的篇幅记述和揭露了清末至20世纪30年代这一时期江湖行当的内幕以及危害社会的种种骗术，劝诫人们不要贪便宜上当受骗，通俗易懂，生动有趣，真实可信，影响深远。作者于上世纪30年代以云游客笔名在北平《时言报》连载书稿内容，1936年由时言报社结集出版。中华书局此次增订再版，请李滨声先生绘制彩色插图50余幅，补充了“小绺门”、“风门”、“雁门”等原书未及的几节文字，并选配多幅珍贵人物照片和历史资料照片。mobi格式。<br> <a href="https://share.weiyun.com/QMws40fA">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EShCc7N6pq5Lk4SLVTD0WVIBNXr10Uu9Suk3QEeKza29Hw?e=kC1pI5">下载链接二</a>  </li>
<li><h5 id="《邓小平时代》"><a href="#《邓小平时代》" class="headerlink" title="《邓小平时代》"></a><strong><a href="https://book.douban.com/subject/20424526/">《邓小平时代》</a></strong></h5>&amp;emsp;&amp;emsp;哈佛大学傅高义教授倾十年心力完成的权威巨著《邓小平时代》，是对邓小平跌宕起伏的一生以及中国惊险崎岖的改革开放之路的全景式描述。作者对邓小平个人性格及执政风格进行了深层分析，并对中国改革开放史进行了完整而独到的阐释，书中涵盖丰富的中外档案资料和研究成果，以及为数众多的作者独家访谈，对中美建交、华国锋历史评估、改革开放的幕后曲折、邓小平和诸多当时关键人物之关系、香港问题、邓小平南巡等重大议题均有详述及剖析。本书既具学院研究的严谨专精，又对中国现实政治与事理人情有透彻把握，被誉为邓小平研究“纪念碑式”的著作。<br>&amp;emsp;&amp;emsp;这是港版无删减版，读完此书，对邓公的敬仰之情犹如滔滔江水！epub格式。<br> <a href="https://share.weiyun.com/IYpzoVKc">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EaZPfzWEuJZHkEPj9rocYy0BWppO2H1XaNQPnnSXlgLR9g?e=Xmk4i0">下载链接二</a>  </li>
<li><h5 id="《潜规则》"><a href="#《潜规则》" class="headerlink" title="《潜规则》"></a><strong><a href="https://book.douban.com/subject/3580750/">《潜规则》</a></strong></h5>&amp;emsp;&amp;emsp;这部以历史为解读对象的著作中，作者以亦雅亦俗、亦庄亦谐的写作方式，叙述了历史上值得人们思考的大大小小的无数案例，在生动、有趣地讲述官场故事的同时，作者透过历史表象，揭示出隐藏在正式规则之下、实际上支配着社会运行的不成文的规矩，并将其名之日“潜规则”，进而指出潜规则的产生在于现实的利害计算与趋利避害。书中对于潜规则的定义、特征，潜规则阴影下皇帝、官员、百姓的不同处境与抉择，潜规则盛行的社会土壤，以及潜规则何时会萎缩，均有论述。潜规则现象产生、盛行于我国的封建社会，但它一时还难以消失，只有加强社会主义民主，健全社会主义法制，才能最后根除潜规则。<br>&amp;emsp;&amp;emsp;读完之后，对于当今的社会关系有了更冷静清晰的认识。epub格式。<br> <a href="https://share.weiyun.com/l9JAoRxC">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EZ3TFnIcfoxHgx-d9s-RK_MBekGZKWtn51G0BHQ-TPzOMw?e=BkP47g">下载链接二</a>  </li>
<li><h5 id="《万历十五年》"><a href="#《万历十五年》" class="headerlink" title="《万历十五年》"></a><strong><a href="https://book.douban.com/subject/1858410/">《万历十五年》</a></strong></h5>&amp;emsp;&amp;emsp;本书是黄仁宇的成名之作，也是他的代表作之一，融会了他数十年人生经历与治学体会，首次以“大历史观”分析明代社会之症结，观察现代中国之来路，给人启发良多。英文原本推出后，被美国多所大学采用为教科书，并两次获得美国书卷奖历史类好书的提名。这是中华书局的增订版，重新核校全部文字，增收黄仁宇《1619年的辽东战役》等数篇文字，精选彩色历史图片10余幅。<br>&amp;emsp;&amp;emsp;因为读了《潜规则》，又来拜读了里面提到的本书。epub格式。<br> <a href="https://share.weiyun.com/RcZdi44z">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EYZ6Wyr5IBVJmvZG3da2-lwB_dulEphOiUA6ZcAJGTvMjQ?e=TtRiPv">下载链接二</a>  </li>
<li><h5 id="《浮生六记》"><a href="#《浮生六记》" class="headerlink" title="《浮生六记》"></a><strong><a href="https://book.douban.com/subject/27006467/">《浮生六记》</a></strong></h5>&amp;emsp;&amp;emsp;这是沈复写给妻子芸娘的绝美情书，被誉为“晚清小红楼梦”。从初见的怦然心动到婚后的举案齐眉；从谈诗论画到赏月弄花，平平淡淡的柴米夫妻，将清贫的日子过成了一首诗。他们遭逢家庭变故，半生坎坷，颠沛流离，却一直相扶相依，不离不弃。芸娘病故后，沈复用清丽典雅之笔，作《浮生六记》六卷，以慰生死隔离之相思，书里有着落花流水的时光散漫，庭园梦境的从容静寂，与布衣蔬食的晨光之美。自晚清至今，已流传一百余年。此版为俞平伯根据光绪四年《独悟庵丛钞》版与光绪三十二年《雁来红丛报》版校勘，同时参考了广陵古籍刻印社1991年影印本、浙江古籍出版社 1995 年‘幽兰珍丛’版、中华书局 2015 年苗怀明评注版。<br> &amp;emsp;&amp;emsp;“我真诚地相信，一个谦卑渺小的生命能快乐地过一辈子，是宇宙间之至美。”（林语堂），读完许久，仍对书中流露出的美好纯洁的感情铭记于心。epub格式。<br> <a href="https://share.weiyun.com/y0T2hW3G">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/ES3GSBv_ERpAnk0iBhwPan0B_31EgNDYVl094exzt8b9pw?e=fAWxuC">下载链接二</a>  </li>
<li><h5 id="《激荡三十年》"><a href="#《激荡三十年》" class="headerlink" title="《激荡三十年》"></a><strong><a href="https://book.douban.com/subject/3151575/">《激荡三十年》</a></strong></h5>&amp;emsp;&amp;emsp;尽管任何一段历史都有它不可替代的独特性，可是1978年—2008年的中国，却是最不可能重复的，在一个拥有近13亿人口的大国里，僵化的计划经济体制日渐瓦解了，一群小人物把中国变成了一个巨大的试验场，它在众口睽睽之下，以不可逆转的姿态向商业社会转轨……<br> &amp;emsp;&amp;emsp;这三十年，是激浪壮阔的三十年，也是充满变革的三十年，还是新旧事物、观念激烈碰撞的三十年。epub格式。<br> <a href="https://share.weiyun.com/cxD73CTh">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/Eduz7f9IQVdJuNXGPSPxh6gBVmBcpLkwnbFrYFpGHv9jhw?e=ETjoKP">下载链接二</a>  </li>
<li><h5 id="《最后的炼金术士：牛顿传》"><a href="#《最后的炼金术士：牛顿传》" class="headerlink" title="《最后的炼金术士：牛顿传》"></a><strong><a href="https://book.douban.com/subject/1023860/">《最后的炼金术士：牛顿传》</a></strong></h5>&amp;emsp;&amp;emsp;作者凭借深厚的科学史家涵养，以极为人性化的角度重新探索了牛顿的一生，他的忧郁的童年时代、幸运的少年时代、成果丰硕的青年时代和权力膨胀的老年时代。本书优越于一般牛顿传记的地方在于作者基于科学发生学的视角，提出了牛顿痴迷炼金术与奠立近代科学基础之间的重大关联。牛顿总共留下了50多万字的炼金术手稿和100多万字的神学手稿，这些工作难道与他的科学发现是完全不相关的？过去的传记作家往往为了神话牛顿的“科学伟人”形象而对他从事炼金术和异端信仰故意避而不谈，而迈克尔·怀特则以特有的直觉和史料求证，借助于牛顿的重要信件和若干从未公开出版过的笔记，阐释了牛顿从事炼金术和神学研究对于他发现万有引力以及后来进行的统一场论研究的紧密关联。<br> &amp;emsp;&amp;emsp;以前关于牛顿还只停留在苹果掉地上发现万有引力的层面，后来从别的地方了解了他在后半生就职于造币厂，遂读此书，更加全面的了解他。pdf格式。<br> <a href="https://share.weiyun.com/smMBRSZd">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:b:/g/personal/14120335_bjtu_edu_cn/ETQRdyOyV39IkjVH_tsMzrQBekcDrV9VFTY23hDupw76OQ?e=8IfGBT">下载链接二</a>  </li>
<li><h5 id="《人类简史》"><a href="#《人类简史》" class="headerlink" title="《人类简史》"></a><strong><a href="https://book.douban.com/subject/25985021/">《人类简史》</a></strong></h5>&amp;emsp;&amp;emsp;本书是以色列新锐历史学家的一部重磅作品。从十万年前有生命迹象开始到21世纪资本、科技交织的人类发展史。十万年前，地球上至少有六个人种，为何今天却只剩下了我们自己？我们曾经只是非洲角落一个毫不起眼的族群，对地球上生态的影响力和萤火虫、猩猩或者水母相差无几。为何我们能登上生物链的顶端，最终成为地球的主宰？从认知革命、农业革命到科学革命，我们真的了解自己吗？我们过得更加快乐吗？我们知道金钱和宗教从何而来，为何产生吗？人类创建的帝国为何一个个衰亡又兴起？为什么地球上几乎每一个社会都有男尊女卑的观念？为何一神教成为最为广泛接受的宗教？科学和资本主义如何成为现代社会最重要的信条？理清影响人类发展的重大脉络，挖掘人类文化、宗教、法律、国家、信贷等产生的根源。这是一部宏大的人类简史，更见微知著、以小写大，让人类重新审视自己。<br> &amp;emsp;&amp;emsp;看着网上到处都在推荐这本书，就读了一下，角度很宏观，启发性很强。epub格式。<br> <a href="https://share.weiyun.com/o0x0epNU">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EXYlbIWdCqFElLMRUpY5RmEBrfJmzjSFaENcd4pFNBQ-xw?e=6UUxMP">下载链接二</a>   </li>
<li><h5 id="《全球通史》"><a href="#《全球通史》" class="headerlink" title="《全球通史》"></a><strong><a href="https://book.douban.com/subject/10583099/">《全球通史》</a></strong></h5>&amp;emsp;&amp;emsp;作者在本书中采用全新的史学观点和方法，将整个世界看作一个不可分割的有机的统一体，从全球的角度而不是从某一国家或某一地区的角度来考察世界各地区人类文明的产生和发展，把研究重点放在对人类历史进程有重大影响的诸历史运动、诸历史事件和它们之间的相互关联和相互影响上，努力反映局部与整体的对抗以及它们之间的相互作用。本书上起人类的起源，下迄21世纪初多极世界相待时期，上下数十万年，一气呵成，除了政治、经济外，还涉及军事、文化、教育、宗教、科学技术、人口、移民、种族关系、道德风尚、思想意识等各个方面。从文字内容来看，作者对庞杂的史料取舍恰当，对各种历史事件着笔简要，边叙边议，文字生动；从编写技巧来看，每章前冠以简明提要，承上启下，便于掌握线索，每章末附有选读书目，便于进一步研究。<br> &amp;emsp;&amp;emsp;从《人类简史》读到了本书，描写很宏观，深受启发。mobi格式。<br> <a href="https://share.weiyun.com/0uChixFN">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EV_M7nvAe5BCkfa7fElKPREBBQNENgRMr8YYzycJYy4rwg?e=pKokHL">下载链接二</a>     </li>
<li><h5 id="《解忧杂货店》"><a href="#《解忧杂货店》" class="headerlink" title="《解忧杂货店》"></a><strong><a href="https://book.douban.com/subject/25862578/">《解忧杂货店》</a></strong></h5>&amp;emsp;&amp;emsp;现代人内心流失的东西，这家杂货店能帮你找回——僻静的街道旁有一家杂货店，只要写下烦恼投进卷帘门的投信口，第二天就会在店后的牛奶箱里得到回答。因男友身患绝症，年轻女孩静子在爱情与梦想间徘徊；克郎为了音乐梦想离家漂泊，却在现实中寸步难行；少年浩介面临家庭巨变，挣扎在亲情与未来的迷茫中……他们将困惑写成信投进杂货店，随即奇妙的事情竟不断发生。生命中的一次偶然交会，将如何演绎出截然不同的人生？“如今回顾写作过程，我发现自己始终在思考一个问题：站在人生的岔路口，人究竟应该怎么做？我希望读者能在掩卷时喃喃自语：我从未读过这样的小说。”——东野圭吾<br> &amp;emsp;&amp;emsp;人们在迷茫的时候，收到关于迷茫的回复就已经大有益处了，希望每个人的一生中都能碰到这样的一件杂货店。epub格式。<br> <a href="https://share.weiyun.com/701e3pdA">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:u:/g/personal/14120335_bjtu_edu_cn/EVCoQaDtzSRBgOxJNphXBuwBnPn7J1xaKrJ75akXIITw4w?e=HAsGfI">下载链接二</a>  </li>
<li><h5 id="《永久记录》"><a href="#《永久记录》" class="headerlink" title="《永久记录》"></a><strong><a href="https://book.douban.com/subject/34862375/">《永久记录》</a></strong></h5>&amp;emsp;&amp;emsp;本书是爱德华•斯诺登的自传，记录了他在童年、少年、成年时期的经历，以及自己价值观变化的全部过程，书中内容既反映了现代网络科技的发展，也表现了作者对美国政府监视行为的不安，并表达了他内心深处的反思与告白。全书分为三个部分：第一部分是斯诺登的童年回忆，他自小开始对计算机程序语言产生浓厚的兴趣，并由此走上成为系统工程师之路，寻找网络的秘密。第二部分是斯诺登受雇于美国情报机构期间的经历，此期间，他冒着极大风险曝光美国政府的大规模监视系统，这一部分还讲到他为建立这个系统所做的工作，以及促使他曝光事件的原因。第三部分是斯诺登逃亡到香港和俄罗斯，联络媒体继续曝光整个事件的经历。在这一部分中，他也袒露了内心的矛盾。他满怀着激情与坦率、智慧与担当写下的这本书，注定将成为数字时代不可忽略的嘹亮回声。<br> &amp;emsp;&amp;emsp;美国错综复杂的情报密云背后，被斯诺登撕开了一个小口，震惊了世界。pdf格式。<br> <a href="https://share.weiyun.com/NWGVbvTm">下载链接一</a>&amp;emsp;&amp;emsp;<a href="https://bjtueducn-my.sharepoint.com/:b:/g/personal/14120335_bjtu_edu_cn/EdJHzq5xLyVHvUtdwfF7CCABa8XFHxDASOToN215-Y2U7g?e=zR4Acq">下载链接二</a></li>
</ul>
<h3 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h3><ul>
<li><h5 id="《从海底出击》"><a href="#《从海底出击》" class="headerlink" title="《从海底出击》"></a><strong><a href="https://www.uump4.net/thread-298302.htm">《从海底出击》</a></strong></h5>&amp;emsp;&amp;emsp;很经典的潜艇战争片，这里放的资源是208分钟的导演剪辑加长版，国德双音轨特效字幕。<br><a href="/download/%E4%BB%8E%E6%B5%B7%E5%BA%95%E5%87%BA%E5%87%BB(%E8%93%9D%E5%85%89%E5%9B%BD%E8%8B%B1%E5%8F%8C%E9%9F%B3%E8%BD%A8%E7%89%B9%E6%95%88%E5%8F%8C%E5%AD%97%E5%B9%95).Das.Boot.1981.BD-1080p.X264.AAC.2AUDIO.CHS.ENG-UUMp4.torrent">种子下载</a>&amp;emsp;&amp;emsp;<a href="ed2k://|file|从海底出击(蓝光国英双音轨特效双字幕).Das.Boot.1981.BD-1080p.X264.AAC.2AUDIO.CHS.ENG-uump4.mp4|4950298918|F9F56F253A8BA44B63BBF47C7D0CF516|h=LVJVVOCGIH7YHVQPBU37YGHW2QTL5BKS|/">电驴链接</a>&amp;emsp;&amp;emsp;<a href="magnet:?xt=urn:btih:A0F9DB18CAD10DD23ECB6C78E4C7A3B223948439">磁力链接</a></li>
</ul>
<h3 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h3><p>&amp;emsp;&amp;emsp;自己看书的话一般都是将书的电子版下载到手机本地，然后使用阅读器看，这样做的好处是一些你懂的的资源可以直接看。我用的是安卓机，阅读器使用的<a href="http://www.moondownload.com/chinese.html">静读天下</a>，自己在google play上买的专业版，不支持iOS系统。大家也可以选择一些其他的支持epub、mobi等主流电子书格式的阅读器。<br>&amp;emsp;&amp;emsp;看电影的话也是同样推荐将电影下载到本地，然后使用本地播放器看。播放软件的话推荐<a href="https://www.videolan.org/">VLC</a>,支持各种操作系统（Windows、Android、iOS、MacOS、Linnux等），也可以选择Potplayer等评价较高的本地播放软件。  </p>
]]></content>
      <categories>
        <category>网络资源</category>
      </categories>
  </entry>
  <entry>
    <title>排序算法总结(PHP 和 C++ 实现)</title>
    <url>/2016/10/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-PHP%E5%92%8CC-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>本文重点讲解冒泡排序、插入排序、希尔排序、归并排序、快速排序和堆排序，代码使用C++和PHP实现。</p>
<span id="more"></span>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><table>
    <tr>
        <th>排序方法</th> 
        <th>平均情况</th>
        <th>最好情况</th>
        <th>最坏情况</th>
        <th>空间复杂度</th>        
        <th>稳定性</th>
    </tr>
    <tr>
        <td>冒泡排序</td>
        <td>$O(n^2)$</td>
        <td>$O(n)$</td>
        <td>$O(n^2)$</td>
        <td>$O(1)$</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td>插入排序</td>
        <td>$O(n^2)$</td>
        <td>$O(n)$</td>
        <td>$O(n^2)$</td>
        <td>$O(1)$</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td>希尔排序</td>
        <td>$O(n^{1.3})$</td>
        <td>$O(nlogn)$</td>
        <td>$O(n^2)$</td>
        <td>$O(1)$</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td>快速排序</td>
        <td>$O(nlogn)$</td>
        <td>$O(nlogn)$</td>
        <td>$O(n^2)$</td>
        <td>$O(nlogn)$</td>
        <td>不稳定</td>
    </tr>
    <tr>
        <td>归并排序</td>
        <td>$O(nlogn)$</td>
        <td>$O(nlogn)$</td>
        <td>$O(nlogn)$</td>
        <td>$O(n)$</td>
        <td>稳定</td>
    </tr>
    <tr>
        <td>堆排序</td>
        <td>$O(nlogn)$</td>
        <td>$O(nlogn)$</td>
        <td>$O(nlogn)$</td>
        <td>$O(1)$</td>
        <td>不稳定</td>
    </tr>
</table>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（bubblesort）是先从数组第一个元素开始，依次比较相邻两个数，若前者比后者大，就将两者交换位置，然后处理下一对，依此类推，不断扫描数组，直到完成排序。时间复杂度最好为$O(n)$，最坏为$O(n^2)$，平均为$O(n^2)$。空间复杂度为O(1)。它是稳定的排序算法。</p>
<h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><p><img src="http://7xsex4.com1.z0.glb.clouddn.com/bubble_sort.gif" alt="冒泡排序"></p>
<h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Comparable&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;Comparable&gt; &amp; a)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len<span class="number">-1</span>; i++)  &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;len<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(a[j], a[j+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PHP实现"><a href="#PHP实现" class="headerlink" title="PHP实现"></a>PHP实现</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">&amp;<span class="variable">$arr</span></span>)</span>&#123;</span><br><span class="line">	<span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="variable">$len</span>-<span class="number">1</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="variable">$j</span>=<span class="number">0</span>; <span class="variable">$j</span>&lt;<span class="variable">$len</span>-<span class="variable">$i</span>-<span class="number">1</span>; <span class="variable">$j</span>++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="variable">$arr</span>[<span class="variable">$j</span>] &gt; <span class="variable">$arr</span>[<span class="variable">$j</span>+<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="keyword">list</span>(<span class="variable">$arr</span>[<span class="variable">$j</span>+<span class="number">1</span>], <span class="variable">$arr</span>[<span class="variable">$j</span>]) = <span class="keyword">array</span>(<span class="variable">$arr</span>[<span class="variable">$j</span>], <span class="variable">$arr</span>[<span class="variable">$j</span>+<span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><pre><code>void BubbleSort(int arr[], int length)
&#123;
    int i = 0;
    int j = 0;
    
    if(length &lt; 1)
    &#123;
        return;
    &#125;
    
    for(i = 0; i &lt; length - 1; i++)
    &#123;
        for(j = i + 1; j &lt; length; j++)
        &#123;
            if(arr[i] &gt; arr[j])&#123;
                swap(&amp;arr[i], &amp;arr[j]);
            &#125;	
        &#125;
     &#125;
&#125;
</code></pre>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（insertsort）是逐一取出元素，在已经排序的元素序列中从后向前扫描，放到适当的位置，它保证了从位置0到位置i-1上的元素是已经排序好的。时间复杂度最好为$O(n)$，最坏为$O(n^2)$，平均为$O(n^2)$。空间复杂度为$O(1)$。它是稳定的排序算法。</p>
<h3 id="示意图-1"><a href="#示意图-1" class="headerlink" title="示意图"></a>示意图</h3><p><img src="http://7xsex4.com1.z0.glb.clouddn.com/insert-sort.gif" alt="插入排序"></p>
<h3 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++实现"></a>C++实现</h3><pre><code>template &lt;typename Comparable&gt;
void insertSort(vector&lt;Comparable&gt; &amp; a) &#123;
    int len = a.size(), j;
    for(int i=1; i&lt;len; i++) &#123;
        Comparable tmp = a[i];
        for(j=i; j&gt;0 &amp;&amp; tmp&lt;a[j-1]; j--)&#123;
            a[j] = a[j-1];
        &#125;
        a[j] = tmp;
    &#125;
&#125;
</code></pre>
<h3 id="PHP实现-1"><a href="#PHP实现-1" class="headerlink" title="PHP实现"></a>PHP实现</h3><pre><code>function insertsort(&amp;$arr) &#123;
    $len = count($arr);
    for($i=1; $i&lt;$len; $i++)&#123;
        $tmp = $arr[$i];
        for($j=$i; $j&gt;0 &amp;&amp; $tmp&lt;$arr[$j-1];$j--) &#123;
            $arr[$j] = $arr[$j-1];
        &#125;
        $arr[$j] = $tmp;
    &#125;
&#125;
</code></pre>
<h3 id="C语言实现-1"><a href="#C语言实现-1" class="headerlink" title="C语言实现"></a>C语言实现</h3><pre><code>void InsertSort(int arr[], int length)
&#123;
    int i = 0;
    int j = 0;
    int tmp = 0;
    
    if(length &lt; 1)
    &#123;
        return;
    &#125;
    for(i = 1; i &lt; length; i++)
    &#123;
        tmp = arr[i];
        for(j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp; j--)
        &#123;
            arr[j] = arr[j - 1];
        &#125;
        arr[j] = tmp; 
    &#125;
&#125;
</code></pre>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序（shellsort），也称缩小增量排序，实质是分组插入排序,选择一个步长，然后按间隔为步长的单元进行排序，步长递归变小，直至为1。时间复杂度最好为$O(nlogn)$，最坏为$O(n^2)$，平均为$O(n^{1.3})$。空间复杂度为O(1)。它是不稳定的排序算法。</p>
<pre><code>原数组：[13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10]
我们以步长为5开始进行排序(一般初始步长为数组长度的一半)，先分组：
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
分组后进行排序：
[10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45]
然后再以3为步长进行排序，先分组：
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
分组后进行排序：
[10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94]
最后以1步长进行排序（此时就是简单的插入排序了）。
</code></pre>
<h3 id="示意图-2"><a href="#示意图-2" class="headerlink" title="示意图"></a>示意图</h3><p><img src="http://7xsex4.com1.z0.glb.clouddn.com/shellsort.gif" alt="希尔排序"></p>
<h3 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++实现"></a>C++实现</h3><pre><code>template &lt;typename Comparable&gt;
void shellSort(vector&lt;Comparable&gt; &amp; a) &#123;
    int len = a.size(), j;
    for(int gap=len/2; gap&gt;0; gap/=2) &#123;
        for(int i=gap; i&lt;len; i++) &#123;
            Comparable tmp = a[i];
            for(j=i; j &gt;= gap &amp;&amp; tmp&lt;a[j-gap]; j-=gap) &#123;
                a[j] = a[j-gap];
            &#125;
            a[j] = tmp;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="PHP实现-2"><a href="#PHP实现-2" class="headerlink" title="PHP实现"></a>PHP实现</h3><pre><code>function shellsort(&amp;$arr)&#123;
    $len = count($arr);
    $step = (int)$len/2;	//php的整数相除不一定是整数,int靠0取整
    for( ;$step&gt;=1; $step=(int)$step/2)&#123;
        for($i=$step; $i&lt;$len; $i++)&#123;
            $tmp = $arr[$i];
            for($j=$i; $j&gt;=$step &amp;&amp; $tmp&lt;$arr[$j-$step]; $j-=$step) &#123;
                $arr[$j] = $arr[$j-$step];
            &#125;
            $arr[$j] = $tmp;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="C语言实现-2"><a href="#C语言实现-2" class="headerlink" title="C语言实现"></a>C语言实现</h3><pre><code>void ShellSort(int arr[], int length)
&#123;
    int i = 0;
    int j = 0;
    int duration = 0;
    int tmp = 0;
    
    if(length &lt; 1)
    &#123;
        return;
    &#125;
    
    for(duration = length / 2; duration &gt; 0; duration /= 2)
    &#123;
        for(i = duration; i &lt; length; i++)
        &#123;
            tmp = arr[i];
            for(j = i; j &gt;= duration; j -= duration)
            &#123;
                if(tmp &lt; arr[j - duration])
                &#123;
                    arr[j] = arr[j - duration];	
                &#125;
                else
                &#123;
                    break;
                &#125;
            &#125;
            arr[j] = tmp;			
        &#125; 
    &#125; 
&#125; 
</code></pre>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序（quicksort），先选择枢纽元，然后把比它小的放在左边，大的放在右边，然后再对左右区间分别使用这一过程，直到区间内只剩一个元素。时间复杂度最好为$O(nlogn)$，最坏为$O(n^2)$，平均为$O(nlogn)$。空间复杂度为$O(nlogn)$。它是不稳定的排序算法。枢纽元的选取使用三数中值法。</p>
<h3 id="示意图-3"><a href="#示意图-3" class="headerlink" title="示意图"></a>示意图</h3><p><img src="http://7xsex4.com1.z0.glb.clouddn.com/quicksort.gif" alt="快速排序"></p>
<h3 id="C-实现-3"><a href="#C-实现-3" class="headerlink" title="C++实现"></a>C++实现</h3><pre><code>//使用三数中值法取枢纽元
template &lt;typename Comparable&gt;	
const Comparable &amp; median3(vector&lt;Comparable&gt; &amp; a, int left, int right) &#123;
    int center = (left + right) / 2 ;
    if(a[center] &lt; a[left]) &#123;
        swap(a[left], a[right]) ;
    &#125;
    if(a[right] &lt; a[left]) &#123;
        swap(a[left], a[right]);
    &#125; 
    if(a[right] &lt; a[center]) &#123;
        swap(a[center], a[right]);
    &#125;
    return a[center];	//在返回中值的时候已经对首、中、尾三个元素进行了排序 
&#125;

template &lt;typename Comparable&gt;
void quicksort_l(vector&lt;Comparable&gt; &amp; a, int left, int right) &#123;
    Comparable pivot = median3(a, left, right);
    int i = left, j = right;
    do &#123;
        while(a[++i] &lt; pivot) &#123;	&#125;	//首、中、尾三个元素已经进行了排序 
        while(pivot &lt; a[--j]) &#123;	&#125;
        if(i &lt; j) &#123;
            swap(a[i], a[j]);
        &#125; 		
    &#125; while(i&lt;=j);
    if(left &lt; j) quicksort_l(a, left, j);	 //对左区间内的元素排序 
    if(i &lt; right) quicksort_l(a, i, right);	//对右区间内的元素排序 	
&#125;
    
template &lt;typename Comparable&gt;
void quickSort(vector&lt;Comparable&gt; &amp; a) &#123;
    quicksort_l(a, 0, a.size() - 1);
&#125;
</code></pre>
<h3 id="PHP实现-3"><a href="#PHP实现-3" class="headerlink" title="PHP实现"></a>PHP实现</h3><pre><code>//调换数组元素顺序
function swap(&amp;$a, &amp;$b) &#123;
    list($b, $a) = array($a, $b);
&#125;

//三数中值,同时对首、中、尾三个元素排序
function med3(&amp;$arr, $left, $right)&#123;
    $center = (int)(($left+$right)/2);
    if($arr[$center] &lt; $arr[$left])&#123;
        swap($arr[$center], $arr[$left]);
    &#125;
    if($arr[$right] &lt; $arr[$left]) &#123;
        swap($arr[$right], $arr[$left]);
    &#125;
    if($arr[$right] &lt; $arr[$center])&#123;
        swap($arr[$right],$arr[$center]);
    &#125;
    return $arr[$center];
&#125;

function quicksort1(&amp;$arr, $left, $right) &#123;
    $key = med3($arr, $left, $right);
    $i = $left;
    $j = $right;
    do &#123;
        while($arr[++$i] &lt; $key) &#123; &#125; 
        while($arr[--$j] &gt; $key) &#123; &#125;
        if($i &lt; $j) &#123;
            swap($arr[$i], $arr[$j]);	
        &#125;
    &#125; while($i &lt;= $j);
    if($j &gt; $left) &#123;
        quicksort1($arr, $left, $j);
    &#125;
    if($i &lt; $right) &#123;
        quicksort1($arr, $i,$right);
    &#125;

&#125;

function quicksort(&amp;$arr) &#123;
    quicksort1($arr, 0, count($arr)-1);
&#125;
</code></pre>
<h3 id="C语言实现-3"><a href="#C语言实现-3" class="headerlink" title="C语言实现"></a>C语言实现</h3><pre><code>void Qsort(int arr[], int start, int end)
&#123;
    int lt = start;
    int gt = end;
    int i = start + 1;
    int pivot = arr[start];
    
    if(start &gt;= end)
    &#123;
        return;
    &#125;
    
    while(i &lt;= gt)
    &#123;
        if(arr[i] &lt; pivot)
        &#123;
            swap(&amp;arr[lt++], &amp;arr[i++]);
        &#125;
        else if(arr[i] &gt; pivot)
        &#123;
            swap(&amp;arr[gt--], &amp;arr[i]);	//此处不能i++，否则原来gt指向的元素没有与pivot进行比较
        &#125;
        else
        &#123;
            i++;
        &#125;		
    &#125;
    
    Qsort(arr, start, lt - 1);
    Qsort(arr, gt + 1, end);
&#125;

void QuickSort(int arr[], int length)
&#123;
    if(length &lt;= 0) 
    &#123;
        return;
    &#125;
    
    Qsort(arr, 0, length - 1);
&#125;
</code></pre>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（mergesort）是将数组分成两半，这两半分别排序后，再归并在一起。排序某一半时，继续沿用同样的排序算法，最终你将归并两个只含一个元素的数组，这样算法的重担都落在“归并”的部分上。该算法是采用分治法的一个非常典型的应用。时间复杂度都为$O(nlogn)$。空间复杂度为$O(n)$。它是稳定的排序算法。</p>
<h3 id="示意图-4"><a href="#示意图-4" class="headerlink" title="示意图"></a>示意图</h3><p><img src="http://7xsex4.com1.z0.glb.clouddn.com/merge_sort.gif" alt="归并排序"></p>
<h3 id="C-实现-4"><a href="#C-实现-4" class="headerlink" title="C++实现"></a>C++实现</h3><pre><code>template &lt;typename Comparable&gt;
void merge(vector&lt;Comparable&gt; &amp; a, vector&lt;Comparable&gt; &amp; tmpArray, int leftPos,  
int rightPos, int rightEnd) &#123;
    int leftEnd = rightPos - 1;		//center
    int tmpPos = leftPos;
    int numElements = rightEnd - leftPos + 1;
    while(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd)  &#123;
        if(a[leftPos] &lt;= a[rightPos]) &#123;
            tmpArray[tmpPos++] = a[leftPos++];
        &#125; else &#123;
            tmpArray[tmpPos++] = a[rightPos++];
        &#125;
    &#125;
    while(leftPos &lt;= leftEnd) &#123;		
        tmpArray[tmpPos++] = a[leftPos++];
    &#125;
    while(rightPos &lt;= rightEnd) &#123;
        tmpArray[tmpPos++] = a[rightPos++];
    &#125;
    for(int i=0; i&lt;numElements; i++, rightEnd--) &#123;
        a[rightEnd] = tmpArray[rightEnd];
    &#125;
&#125;

template &lt;typename Comparable&gt;
void mergeSort_l(vector&lt;Comparable&gt; &amp; a, vector&lt;Comparable&gt; &amp; tmpArray, int left, int right) &#123;
    if(left &lt; right) &#123;
        int center = (left + right) / 2;
        mergeSort_l(a, tmpArray, left, center);		//对半个数组分别进行排序 
        mergeSort_l(a, tmpArray, center+1, right);
        merge(a, tmpArray, left, center+1, right);
    &#125;
&#125;

template &lt;typename Comparable&gt;
void mergeSort(vector&lt;Comparable&gt; &amp; a) &#123;
    vector&lt;Comparable&gt; tmpArray(a.size());
    mergeSort_l(a, tmpArray, 0, a.size()-1);
&#125;
</code></pre>
<h3 id="PHP实现-4"><a href="#PHP实现-4" class="headerlink" title="PHP实现"></a>PHP实现</h3><pre><code>function mergeSort(&amp;$arr) &#123;
    mergeSort1($arr,0, count($arr)-1);
&#125;

function mergeSort1(&amp;$arr, $left, $right) &#123;   
    if($left &lt; $right) &#123; 	
        $middle = (int) (($left + $right) / 2);
        mergeSort1($arr, $left, $middle);		//对半个数组分别进行排序 
        mergeSort1($arr, $middle+1, $right);		
        merge($arr, $left, $middle+1, $right);
    &#125;
&#125;

function merge(&amp;$arr, $leftPos, $rightPos, $rightEnd)&#123;
    $tmpArr = array();
    $leftEnd = $rightPos - 1;
    $tmpPos = $leftPos;
    $numElements = $rightEnd - $leftPos + 1;
    while($leftPos &lt;= $leftEnd &amp;&amp; $rightPos &lt;= $rightEnd)  &#123;
        if($arr[$leftPos] &lt;= $arr[$rightPos]) &#123;
            $tmpArr[$tmpPos++] = $arr[$leftPos++];
        &#125; else &#123;
            $tmpArr[$tmpPos++] = $arr[$rightPos++];
        &#125;
    &#125;
    while($leftPos &lt; $leftEnd) &#123;
        $tmpArr[$tmpPos++] = $arr[$leftPos++];
    &#125;
    while($rightPos &lt; $rightEnd) &#123;
        $tmpArr[$tmpPos++] = $arr[$rightPos++];
    &#125;
    for($i=0; $i&lt;$numElements; $i++, $rightEnd--) &#123;
        $arr[$rightEnd] = $tmpArr[$rightEnd];
    &#125;
&#125;
</code></pre>
<h3 id="C语言实现-4"><a href="#C语言实现-4" class="headerlink" title="C语言实现"></a>C语言实现</h3><pre><code>void Merge(int arr[], int tmpArr[], int leftPos, int rightPos, int rightEnd) 
&#123;
    int i = leftPos;
    int j = rightPos;
    int tmpPos = 0;
    int numElements = rightEnd - leftPos + 1;
    int leftEnd = rightPos - 1;
        
    for(tmpPos = leftPos; tmpPos &lt;= rightEnd; tmpPos++)
    &#123;
        if(i &gt; leftEnd)
        &#123;
            tmpArr[tmpPos] = arr[j++];
        &#125; 
        else if(j &gt; rightEnd)
        &#123;
            tmpArr[tmpPos] = arr[i++];
        &#125;
        else if(arr[i] &lt;= arr[j])
        &#123;
            tmpArr[tmpPos] = arr[i++];
        &#125;
        else
        &#123;
            tmpArr[tmpPos] = arr[j++];
        &#125;
     &#125;
     
     for(i = 0; i &lt; numElements; i++, rightEnd--)
     &#123;
     	arr[rightEnd] = tmpArr[rightEnd];
     &#125;
&#125;

void MSort(int arr[], int tmpArr[], int start, int end)
&#123;
    int mid = 0;
    
    if(start &gt;= end)
    &#123;
        return;
    &#125;
    
    mid = (start + end) / 2;
    MSort(arr, tmpArr, start, mid);
    MSort(arr, tmpArr, mid + 1, end);
    Merge(arr, tmpArr, start, mid + 1, end);
&#125;

void MergeSort(int arr[], int length)
&#123;
    int *tmpArr;
    
    tmpArr = (int *)malloc(length * sizeof(int));
    if(tmpArr != NULL) 
    &#123;
        MSort(arr, tmpArr, 0, length - 1);
        free(tmpArr);
    &#125;
    else
    &#123;
        return;
    &#125;
&#125;
</code></pre>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>以线性时间建立二叉堆，然后依次通过下滤操作建立一个$max$堆，建立完成后依次通过<code>deleteMax</code>操作，将删除后的元素移至堆尾，完成操作。时间复杂度都为$O(nlogn)$。空间复杂度为$O(n)$。它是不稳定的排序算法。具体步骤如下：  </p>
<ul>
<li><strong>建立最大堆（build max heap）</strong>：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n&#x2F;2开始的元素均为大根堆。于是只要从n&#x2F;2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。  </li>
<li><strong>堆排序（heapsort）</strong>：由于堆是用数组模拟的,在得到一个大根堆后，数组内部并不是有序的，因此需要将数组有序化。思想是移除根节点，并做下滤操作。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做下滤操作。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做下滤操作。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。</li>
</ul>
<h3 id="示意图-5"><a href="#示意图-5" class="headerlink" title="示意图"></a>示意图</h3><p><img src="http://7xsex4.com1.z0.glb.clouddn.com/Heapsort.gif" alt="堆排序"></p>
<h3 id="C-实现-5"><a href="#C-实现-5" class="headerlink" title="C++实现"></a>C++实现</h3><pre><code>inline int leftChild(int i) &#123;
    return 2 * i;
&#125;

template &lt;typename Comparable&gt;
void percDown(vector &lt;Comparable&gt; &amp; a, int i, int n) &#123;
    int child;
    Comparable tmp;
    for(tmp=a[i]; leftChild(i)&lt;n; i=child) &#123;		//leftChild确保在堆内计算 
        child = leftChild(i);
        if(child!=n-1 &amp;&amp; a[child]&lt;a[child+1]) &#123;
            child++;
        &#125;
        if(tmp &lt; a[child]) &#123;
            a[i] = a[child];
        &#125; else &#123;
            break;
        &#125;
    &#125;
    a[i] = tmp;
&#125;

template &lt;typename Comparable&gt;
void heapSort(vector &lt;Comparable&gt; &amp; a) &#123;
    for(int i=a.size()/2; i&gt;=0; i--) &#123;		//建立max堆 
        percDown(a, i, a.size());
    &#125;
    for(int j=a.size()-1; j&gt;0; j--) &#123;		//进行堆排序
        swap(a[0], a[j]);
        percDown(a, 0, j);
    &#125;
&#125;
</code></pre>
<h3 id="PHP实现-5"><a href="#PHP实现-5" class="headerlink" title="PHP实现"></a>PHP实现</h3><pre><code>function swap(&amp;$a, &amp;$b) &#123;		//调换数组元素
    list($b, $a) = array($a, $b);
&#125;

function leftChild($i) &#123;
    return 2 * $i;
&#125;

function percDown(&amp;$arr, $i, $n) &#123;
    for($tmp=$arr[$i]; leftChild($i)&lt;$n; $i=$child) &#123;		 
        $child = leftChild($i);
        if($child!=$n-1 &amp;&amp; $arr[$child]&lt;$arr[$child+1]) &#123;
            $child++;
        &#125;
        if($tmp &lt; $arr[$child]) &#123;
            $arr[$i] = $arr[$child];
        &#125; else &#123;
            break;
        &#125;
    &#125;
    $arr[$i] = $tmp;
&#125;

function heapSort(&amp;$arr) &#123;
    $len = count($arr);
    for($i=(int) ($len/2); $i&gt;=0; $i--) &#123;		 
        percDown($arr, $i, $len);
    &#125;
    for($j=$len-1; $j&gt;0; $j--) &#123;		
        swap($arr[0], $arr[$j]);
        percDown($arr, 0, $j);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
