<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[新阶段学习]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%96%B0%E9%98%B6%E6%AE%B5%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[软考考完了，开始自己新的学习历程吧，先mark两门课程。 谷歌的《机器学习速成课程》和吴恩达的《深度学习工程师》 学习打卡进度： 20180528 Reducing Loss20180531 使用TF的基本步骤20180604 验证 (Validation)神经网络和深度学习 1.5 关于这门课 20180611 2.9 logistic中的梯度下降法20180612 3.1 神经网络概览20180613 3.9 神经网络的梯度下降法20180614 4.6 前向和反向传播20180619 神经网络和深度学习学习完毕，打算完成本章编程习题。mark书《Deep learning》20180702 练习assignment2_220180705 assignment2_2结束，改善深层神经网络：超参数调试、正则化以及优化1.1结束，后续边看新的边练习旧的。20180712 1.4 正则化]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo再折腾]]></title>
    <url>%2F2017%2F11%2F30%2Fhexo%E5%86%8D%E6%8A%98%E8%85%BE%2F</url>
    <content type="text"><![CDATA[转眼间，自己已经从学校毕业走入职场，打算重新拾起博客，记录学习的历程。因为之前的博客是在实验室电脑上更新的，离开学校想要继续写博客，需要在工作电脑上重新搭建博客环境。自己折腾了许久，主要记录下迁移过程中的一些问题吧。 1、hexo迁移若更换电脑还想保留原博客，需要注意备份包含yourname.github.io所在的整个博客目录。在新电脑重新安装git和Node.js后，使用npm安装hexo。然后hexo init新建博客目录后，将之前博客目录里的_config.yml文件和别的比如post里之前的文章也放到新的目录里，这样你就可以接着之前的进度进行更新，不会丢失掉以前的内容，说白了是把以前的文档先copy到本地，然后在此基础上继续更新，毕竟博客在github里面都是在yourname.github.io里面保存着的。需要注意的是在新电脑上需要重新添加git的SSH key，这样新电脑才可以hexo deploy新文章。 2、数学公式下面我的博客和主题的版本信息： hexo: 3.4.2 next主题 version: 5.1.3之前搭建博客的时候，写数学公式主要是用的hexo-math插件，但重新安装的时候各种调不出来，决定使用next主题自带的 # MathJax Support mathjax: enable: true per_page: true cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 这样可以不使用插件就能正常渲染公式。需要注意的需要在有公式的文章的Front-matter区域添加mathjax: true，这样就能正常显示公式了。自此，博客已经在新电脑上生根发芽，希望以后能够坚持记录自己学到的一些东西吧。 ##3、博客功能丰富 另外，给自己的博客使用leancloud添加了评论和文章阅读量统计功能。 ##参考资料：(1)leanCloud,实现文章阅读量统计(2)第三方服务集成]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结(PHP 和 C++ 实现)]]></title>
    <url>%2F2016%2F10%2F10%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93-PHP%E5%92%8CC-%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[本文重点讲解冒泡排序、插入排序、希尔排序、归并排序、快速排序和堆排序，代码使用C++和PHP实现。 概述 排序方法 平均情况 最好情况 最坏情况 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n^{1.3})$ $O(nlogn)$ $O(n^2)$ $O(1)$ 不稳定 快速排序 $O(nlogn)$ $O(nlogn)$ $O(n^2)$ $O(nlogn)$ 不稳定 归并排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(n)$ 稳定 堆排序 $O(nlogn)$ $O(nlogn)$ $O(nlogn)$ $O(1)$ 不稳定 冒泡排序冒泡排序（bubblesort）是先从数组第一个元素开始，依次比较相邻两个数，若前者比后者大，就将两者交换位置，然后处理下一对，依此类推，不断扫描数组，直到完成排序。时间复杂度最好为$O(n)$，最坏为$O(n^2)$，平均为$O(n^2)$。空间复杂度为O(1)。它是稳定的排序算法。 示意图 C++实现template &lt;typename Comparable&gt; void bubbleSort(vector&lt;Comparable&gt; &amp; a) { int len = a.size(); for(int i=0; i&lt;len-1; i++) { for(int j=0; j&lt;len-1-i; j++) { if(a[j] &gt; a[j+1]) { swap(a[j], a[j+1]); } } } }PHP实现function bubbleSort(&amp;$arr){ $len = count($arr); for($i=0; $i&lt;$len-1; $i++){ for($j=0; $j&lt;$len-$i-1; $j++){ if($arr[$j] &gt; $arr[$j+1]){ list($arr[$j+1], $arr[$j]) = array($arr[$j], $arr[$j+1]); } } } }C语言实现void BubbleSort(int arr[], int length) { int i = 0; int j = 0; if(length &lt; 1) { return; } for(i = 0; i &lt; length - 1; i++) { for(j = i + 1; j &lt; length; j++) { if(arr[i] &gt; arr[j]){ swap(&amp;arr[i], &amp;arr[j]); } } } }插入排序插入排序（insertsort）是逐一取出元素，在已经排序的元素序列中从后向前扫描，放到适当的位置，它保证了从位置0到位置i-1上的元素是已经排序好的。时间复杂度最好为$O(n)$，最坏为$O(n^2)$，平均为$O(n^2)$。空间复杂度为$O(1)$。它是稳定的排序算法。 示意图 C++实现template &lt;typename Comparable&gt; void insertSort(vector&lt;Comparable&gt; &amp; a) { int len = a.size(), j; for(int i=1; i&lt;len; i++) { Comparable tmp = a[i]; for(j=i; j&gt;0 &amp;&amp; tmp&lt;a[j-1]; j--){ a[j] = a[j-1]; } a[j] = tmp; } }PHP实现function insertsort(&amp;$arr) { $len = count($arr); for($i=1; $i&lt;$len; $i++){ $tmp = $arr[$i]; for($j=$i; $j&gt;0 &amp;&amp; $tmp&lt;$arr[$j-1];$j--) { $arr[$j] = $arr[$j-1]; } $arr[$j] = $tmp; } }C语言实现void InsertSort(int arr[], int length) { int i = 0; int j = 0; int tmp = 0; if(length &lt; 1) { return; } for(i = 1; i &lt; length; i++) { tmp = arr[i]; for(j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; tmp; j--) { arr[j] = arr[j - 1]; } arr[j] = tmp; } }希尔排序希尔排序（shellsort），也称缩小增量排序，实质是分组插入排序,选择一个步长，然后按间隔为步长的单元进行排序，步长递归变小，直至为1。时间复杂度最好为$O(nlogn)$，最坏为$O(n^2)$，平均为$O(n^{1.3})$。空间复杂度为O(1)。它是不稳定的排序算法。 原数组：[13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10] 我们以步长为5开始进行排序(一般初始步长为数组长度的一半)，先分组： 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 分组后进行排序： [10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45] 然后再以3为步长进行排序，先分组： 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 分组后进行排序： [10 14 13 25 23 33 27 25 59 39 65 73 45 94 82 94] 最后以1步长进行排序（此时就是简单的插入排序了）。示意图 C++实现template &lt;typename Comparable&gt; void shellSort(vector&lt;Comparable&gt; &amp; a) { int len = a.size(), j; for(int gap=len/2; gap&gt;0; gap/=2) { for(int i=gap; i&lt;len; i++) { Comparable tmp = a[i]; for(j=i; j &gt;= gap &amp;&amp; tmp&lt;a[j-gap]; j-=gap) { a[j] = a[j-gap]; } a[j] = tmp; } } }PHP实现function shellsort(&amp;$arr){ $len = count($arr); $step = (int)$len/2; //php的整数相除不一定是整数,int靠0取整 for( ;$step&gt;=1; $step=(int)$step/2){ for($i=$step; $i&lt;$len; $i++){ $tmp = $arr[$i]; for($j=$i; $j&gt;=$step &amp;&amp; $tmp&lt;$arr[$j-$step]; $j-=$step) { $arr[$j] = $arr[$j-$step]; } $arr[$j] = $tmp; } } }C语言实现void ShellSort(int arr[], int length) { int i = 0; int j = 0; int duration = 0; int tmp = 0; if(length &lt; 1) { return; } for(duration = length / 2; duration &gt; 0; duration /= 2) { for(i = duration; i &lt; length; i++) { tmp = arr[i]; for(j = i; j &gt;= duration; j -= duration) { if(tmp &lt; arr[j - duration]) { arr[j] = arr[j - duration]; } else { break; } } arr[j] = tmp; } } } 快速排序快速排序（quicksort），先选择枢纽元，然后把比它小的放在左边，大的放在右边，然后再对左右区间分别使用这一过程，直到区间内只剩一个元素。时间复杂度最好为$O(nlogn)$，最坏为$O(n^2)$，平均为$O(nlogn)$。空间复杂度为$O(nlogn)$。它是不稳定的排序算法。枢纽元的选取使用三数中值法。 示意图 C++实现//使用三数中值法取枢纽元 template &lt;typename Comparable&gt; const Comparable &amp; median3(vector&lt;Comparable&gt; &amp; a, int left, int right) { int center = (left + right) / 2 ; if(a[center] &lt; a[left]) { swap(a[left], a[right]) ; } if(a[right] &lt; a[left]) { swap(a[left], a[right]); } if(a[right] &lt; a[center]) { swap(a[center], a[right]); } return a[center]; //在返回中值的时候已经对首、中、尾三个元素进行了排序 } template &lt;typename Comparable&gt; void quicksort_l(vector&lt;Comparable&gt; &amp; a, int left, int right) { Comparable pivot = median3(a, left, right); int i = left, j = right; do { while(a[++i] &lt; pivot) { } //首、中、尾三个元素已经进行了排序 while(pivot &lt; a[--j]) { } if(i &lt; j) { swap(a[i], a[j]); } } while(i&lt;=j); if(left &lt; j) quicksort_l(a, left, j); //对左区间内的元素排序 if(i &lt; right) quicksort_l(a, i, right); //对右区间内的元素排序 } template &lt;typename Comparable&gt; void quickSort(vector&lt;Comparable&gt; &amp; a) { quicksort_l(a, 0, a.size() - 1); }PHP实现//调换数组元素顺序 function swap(&amp;$a, &amp;$b) { list($b, $a) = array($a, $b); } //三数中值,同时对首、中、尾三个元素排序 function med3(&amp;$arr, $left, $right){ $center = (int)(($left+$right)/2); if($arr[$center] &lt; $arr[$left]){ swap($arr[$center], $arr[$left]); } if($arr[$right] &lt; $arr[$left]) { swap($arr[$right], $arr[$left]); } if($arr[$right] &lt; $arr[$center]){ swap($arr[$right],$arr[$center]); } return $arr[$center]; } function quicksort1(&amp;$arr, $left, $right) { $key = med3($arr, $left, $right); $i = $left; $j = $right; do { while($arr[++$i] &lt; $key) { } while($arr[--$j] &gt; $key) { } if($i &lt; $j) { swap($arr[$i], $arr[$j]); } } while($i &lt;= $j); if($j &gt; $left) { quicksort1($arr, $left, $j); } if($i &lt; $right) { quicksort1($arr, $i,$right); } } function quicksort(&amp;$arr) { quicksort1($arr, 0, count($arr)-1); }C语言实现void Qsort(int arr[], int start, int end) { int lt = start; int gt = end; int i = start + 1; int pivot = arr[start]; if(start &gt;= end) { return; } while(i &lt;= gt) { if(arr[i] &lt; pivot) { swap(&amp;arr[lt++], &amp;arr[i++]); } else if(arr[i] &gt; pivot) { swap(&amp;arr[gt--], &amp;arr[i]); //此处不能i++，否则原来gt指向的元素没有与pivot进行比较 } else { i++; } } Qsort(arr, start, lt - 1); Qsort(arr, gt + 1, end); } void QuickSort(int arr[], int length) { if(length &lt;= 0) { return; } Qsort(arr, 0, length - 1); }归并排序归并排序（mergesort）是将数组分成两半，这两半分别排序后，再归并在一起。排序某一半时，继续沿用同样的排序算法，最终你将归并两个只含一个元素的数组，这样算法的重担都落在“归并”的部分上。该算法是采用分治法的一个非常典型的应用。时间复杂度都为$O(nlogn)$。空间复杂度为$O(n)$。它是稳定的排序算法。 示意图 C++实现template &lt;typename Comparable&gt; void merge(vector&lt;Comparable&gt; &amp; a, vector&lt;Comparable&gt; &amp; tmpArray, int leftPos, int rightPos, int rightEnd) { int leftEnd = rightPos - 1; //center int tmpPos = leftPos; int numElements = rightEnd - leftPos + 1; while(leftPos &lt;= leftEnd &amp;&amp; rightPos &lt;= rightEnd) { if(a[leftPos] &lt;= a[rightPos]) { tmpArray[tmpPos++] = a[leftPos++]; } else { tmpArray[tmpPos++] = a[rightPos++]; } } while(leftPos &lt;= leftEnd) { tmpArray[tmpPos++] = a[leftPos++]; } while(rightPos &lt;= rightEnd) { tmpArray[tmpPos++] = a[rightPos++]; } for(int i=0; i&lt;numElements; i++, rightEnd--) { a[rightEnd] = tmpArray[rightEnd]; } } template &lt;typename Comparable&gt; void mergeSort_l(vector&lt;Comparable&gt; &amp; a, vector&lt;Comparable&gt; &amp; tmpArray, int left, int right) { if(left &lt; right) { int center = (left + right) / 2; mergeSort_l(a, tmpArray, left, center); //对半个数组分别进行排序 mergeSort_l(a, tmpArray, center+1, right); merge(a, tmpArray, left, center+1, right); } } template &lt;typename Comparable&gt; void mergeSort(vector&lt;Comparable&gt; &amp; a) { vector&lt;Comparable&gt; tmpArray(a.size()); mergeSort_l(a, tmpArray, 0, a.size()-1); }PHP实现function mergeSort(&amp;$arr) { mergeSort1($arr,0, count($arr)-1); } function mergeSort1(&amp;$arr, $left, $right) { if($left &lt; $right) { $middle = (int) (($left + $right) / 2); mergeSort1($arr, $left, $middle); //对半个数组分别进行排序 mergeSort1($arr, $middle+1, $right); merge($arr, $left, $middle+1, $right); } } function merge(&amp;$arr, $leftPos, $rightPos, $rightEnd){ $tmpArr = array(); $leftEnd = $rightPos - 1; $tmpPos = $leftPos; $numElements = $rightEnd - $leftPos + 1; while($leftPos &lt;= $leftEnd &amp;&amp; $rightPos &lt;= $rightEnd) { if($arr[$leftPos] &lt;= $arr[$rightPos]) { $tmpArr[$tmpPos++] = $arr[$leftPos++]; } else { $tmpArr[$tmpPos++] = $arr[$rightPos++]; } } while($leftPos &lt; $leftEnd) { $tmpArr[$tmpPos++] = $arr[$leftPos++]; } while($rightPos &lt; $rightEnd) { $tmpArr[$tmpPos++] = $arr[$rightPos++]; } for($i=0; $i&lt;$numElements; $i++, $rightEnd--) { $arr[$rightEnd] = $tmpArr[$rightEnd]; } }C语言实现void Merge(int arr[], int tmpArr[], int leftPos, int rightPos, int rightEnd) { int i = leftPos; int j = rightPos; int tmpPos = 0; int numElements = rightEnd - leftPos + 1; int leftEnd = rightPos - 1; for(tmpPos = leftPos; tmpPos &lt;= rightEnd; tmpPos++) { if(i &gt; leftEnd) { tmpArr[tmpPos] = arr[j++]; } else if(j &gt; rightEnd) { tmpArr[tmpPos] = arr[i++]; } else if(arr[i] &lt;= arr[j]) { tmpArr[tmpPos] = arr[i++]; } else { tmpArr[tmpPos] = arr[j++]; } } for(i = 0; i &lt; numElements; i++, rightEnd--) { arr[rightEnd] = tmpArr[rightEnd]; } } void MSort(int arr[], int tmpArr[], int start, int end) { int mid = 0; if(start &gt;= end) { return; } mid = (start + end) / 2; MSort(arr, tmpArr, start, mid); MSort(arr, tmpArr, mid + 1, end); Merge(arr, tmpArr, start, mid + 1, end); } void MergeSort(int arr[], int length) { int *tmpArr; tmpArr = (int *)malloc(length * sizeof(int)); if(tmpArr != NULL) { MSort(arr, tmpArr, 0, length - 1); free(tmpArr); } else { return; } }堆排序以线性时间建立二叉堆，然后依次通过下滤操作建立一个$max$堆，建立完成后依次通过deleteMax操作，将删除后的元素移至堆尾，完成操作。时间复杂度都为$O(nlogn)$。空间复杂度为$O(n)$。它是不稳定的排序算法。具体步骤如下： 建立最大堆（build max heap）：若数组下标范围为0~n，考虑到单独一个元素是大根堆，则从下标n/2开始的元素均为大根堆。于是只要从n/2-1开始，向前依次构造大根堆，这样就能保证，构造到某个节点时，它的左右子树都已经是大根堆。 堆排序（heapsort）：由于堆是用数组模拟的,在得到一个大根堆后，数组内部并不是有序的，因此需要将数组有序化。思想是移除根节点，并做下滤操作。第一次将heap[0]与heap[n-1]交换，再对heap[0…n-2]做下滤操作。第二次将heap[0]与heap[n-2]交换，再对heap[0…n-3]做下滤操作。重复该操作直至heap[0]和heap[1]交换。由于每次都是将最大的数并入到后面的有序区间，故操作完后整个数组就是有序的了。 示意图 C++实现inline int leftChild(int i) { return 2 * i; } template &lt;typename Comparable&gt; void percDown(vector &lt;Comparable&gt; &amp; a, int i, int n) { int child; Comparable tmp; for(tmp=a[i]; leftChild(i)&lt;n; i=child) { //leftChild确保在堆内计算 child = leftChild(i); if(child!=n-1 &amp;&amp; a[child]&lt;a[child+1]) { child++; } if(tmp &lt; a[child]) { a[i] = a[child]; } else { break; } } a[i] = tmp; } template &lt;typename Comparable&gt; void heapSort(vector &lt;Comparable&gt; &amp; a) { for(int i=a.size()/2; i&gt;=0; i--) { //建立max堆 percDown(a, i, a.size()); } for(int j=a.size()-1; j&gt;0; j--) { //进行堆排序 swap(a[0], a[j]); percDown(a, 0, j); } }PHP实现function swap(&amp;$a, &amp;$b) { //调换数组元素 list($b, $a) = array($a, $b); } function leftChild($i) { return 2 * $i; } function percDown(&amp;$arr, $i, $n) { for($tmp=$arr[$i]; leftChild($i)&lt;$n; $i=$child) { $child = leftChild($i); if($child!=$n-1 &amp;&amp; $arr[$child]&lt;$arr[$child+1]) { $child++; } if($tmp &lt; $arr[$child]) { $arr[$i] = $arr[$child]; } else { break; } } $arr[$i] = $tmp; } function heapSort(&amp;$arr) { $len = count($arr); for($i=(int) ($len/2); $i&gt;=0; $i--) { percDown($arr, $i, $len); } for($j=$len-1; $j&gt;0; $j--) { swap($arr[0], $arr[$j]); percDown($arr, 0, $j); } }]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解计算机系统》读书笔记]]></title>
    <url>%2F2016%2F07%2F17%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[花了大概一个多月的时间，趁着实习的空闲把这本书看完了，感觉本书对于计算机的整个宏观讲的很不错，但在操作系统方面讲的还不够深入，自己看这本书主要是为了自己以后的校招做准备，弥补下自己在操作系统方面的短板。 外壳是一个命令行解释器，它输出一个提示符，等待你输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的外壳命令，那么外壳就假设这是一个可执行文件的名字，它将加载并运行这个文件。 驱动计算机进步的两大动力： 要计算机做的更多——并发（一个同时具有多个活动的系统） 要计算机做的更快——并行（用并发使系统运行的更快） 同变量类似，指针也有两个方面： 值（表示某个对象的地址） 类型（表示那个位置上存储的对象的类型） 对于一个字长为w位的机器而言，虚拟地址的范围为$0\sim2^w$，程序最多访问$2^w$个字节。 多字节对象都被存储为连续的字节序列，对象的地址为所使用字节的最小地址。 Unix外壳创建的每个进程开始时都有三个打开的文件：标准输入（0）、标准输出（1）和标准错误（2）。头文件&lt;unistd.h&gt;定义了常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO，它们可用来代替显式的描述值。 Unix内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向v-node表。每个进程都有自己单独的描述符表，所有的进程共享同一个打开文件表和v-node表。 客户端-服务器模型中的基本操作是事务（跟数据库事务完全不一样），它由四步组成：客户端发送请求；服务器处理请求；服务器发送响应；客户端处理响应。 编写高效程序需要做到以下几点： 必须选择一种合适的数据结构和算法。 必须编写出编译器能够有效优化以转换成可执行代码的源代码。 对处理运算量特别大的计算，将一个任务分成多个部分。 在一个使用投机执行的处理器中，处理器会开始执行预测的分支目标处的指令,这样做会避免修改任何实际的寄存器或存储器位置，知道确定了实际的结果。如果预测是正确，那么处理器就会“提交”投机执行的指令的结果，把它们存储到寄存器或存储器中。如果预测是错误的，处理器必须丢弃掉所有投机执行的结果，在正确的位置，重新开始取指令的过程。这样做会引起预测错服除法，因为在产生又有用的结果前，必须重新填充指令流水线。为保证分之预测除法不会阻碍程序的效率，可以使用以下原则： 不要过分关系可预测的分支。 书写使用条件传送的代码，使用“功能式的”代码替代“命令式的”代码。 #命令式 if(a[i] &gt; b[i]) { int t = a[i]; a[i] = b[i]; b[i] = t; } #功能式 int min = a[i] &lt; b[i] ? a[i] : b[i]; int max = a[i] &lt; b[i] ? b[i] : a[i]; a[i] = min; b[i] = max; 优化程序性能的基本策略： 高级设计。为遇到的问题选择适当的算法和数据结构。 基本编码原则。 消除连续的函数调用，在可能时将循环移到循环外。 消除不必要的存储器引用，引入临时变量来保存中间结果。 低级优化。 展开循环，降低开销。 用功能的风格重写条件操作，使得编译采用条件数据传递。 Amdahl定律：考虑一个系统，在其中执行某个应用程序需要时间，假设系统的某个部分需要这个时间的百分比为$\alpha$，而我们将它的性能提高到了$k$倍，即这个部分原来$ \sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6} $需要时间$\alpha\bulletT_{old}$，而现在需要时间$\alphaT_{old}/k$ ，因此整个执行时间会是：$$T_{new}=(1-\alpha)T_{old}+(\alphaT_{old})/k$=T_{old}[(1-\alpha)+\alpha/k]$$据此，我们可以计算加速比$S=T_{old}/T_{new}$为：$S=\frac{1}{(1-\alpha)+\alpha/k}$。要想大幅度提高整个系统的速度，我们必须提高整个系统很大一部分的速度。 一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身，这种倾向性被称为局部性原理，这是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响，分为时间局部性和空间局部性。 量化评价程序局部性的原则： 重复引用一个变量的程序有良好的时间局部性。 对于具有步长为k的引用模式的程序，步长越小，空间局部性约好。具有步长为1的引用模式的程序有很好的空间局部性，在存储器中以大步长跳来跳去的程序空间局部性会很差。 对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。 高速缓存的写操作： 直写：立即将w的高速缓存块协会到紧接着的低一层中。虽然简单，但缺点是每次写都会引起总线流量。 写回：尽可能的推迟存储器更新，只有当替换算法要驱逐更新过的块时，才把它写到紧接着的低一层中。能显著地减少总线流量，但是增加了复杂性。 基本存储技术包括随机存储器(RAM)、非易失性存储器(ROM，只读存储器)和磁盘。RAM包括静态RAM(SRAM，贵、快，可作CPU芯片上的高速缓存，也可以用作芯片下的高速缓存)和动态RAM(DRAM，便宜、慢，用作主存和图形帧缓冲区)。 之后Unix外壳调用操作系统中的加载器函数，它拷贝可执行文件中的代码和数据到存储器，然后将控制转移到这个程序的开头。 程序是一堆代码和数据，可以作为目标模块存放于磁盘上，或者作为段存在于地址空间中。进程是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文的。上下文是由程序正确运行所需的状态组成的，包括存放在存储器中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。 进程提供给应用程序的关键抽象： 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。 一个私有的地址空间，它提供一个假象，好像我们的程序的独占地使用存储器系统。 多个流并发地执行的一般现象称为并发，一个进程和其他进程轮流运行的概念称为多任务； 上下文切换： 保存当前进程的上下文。 回复某个先前被抢占的进程的被保存的上下文。 将控制传递给这个新恢复的进程。 一个终止了但还未被回首的进程称为僵死进程。 fork是一次调用两次返回：一次是在调用进程（父进程）中，返回子进程的pid；一次是在新创建的子进程中，返回0。因为子进程的pid总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。 虚拟存储器是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的、一致的和私有的地址空间。它有三个重要能力： 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只包括活动区域，并根据需要在磁盘和主存见来回传送数据，高效地使用主存。 为每个进程提供了一致的地址空间，从而简化了存储器管理。 保护每个进程的地址空间不被其他进程破坏。 对于C语言来说，常见的管理和使用虚拟存储器的错误有： 间接引用坏指针。 读取未初始化的存储器。 允许栈缓冲区溢出。 假设指针和它们指向的对象大小相同。 引用指针而不是它们所指向的对象。 误解指针运算。 引用不存在的变量，引起内存器泄漏。 注：12条公式错误没解决]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL中"#"、"&"和"？"的作用]]></title>
    <url>%2F2016%2F06%2F26%2FURL%E4%B8%AD%E8%8B%A5%E5%B9%B2%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在本文中我总结了下#、？、&amp;在URL中的作用。 #URL中的#代表网页中的一个位置，其右边的字符就是该位置的标识符。比如http://www.example.com/index.html#print就代表网页index.html的print位置。浏览器在读取这个URL后，会自动将print位置滚动至可视区域。为网页位置指定标识符有两个方法:使用锚点，比如&lt;a name=&quot;print&quot;&gt;&lt;/a&gt;；** 使用id属性 **，比如&lt;div id=&quot;print&quot;&gt;。#在URL中的具体作用如下： HTTP请求不包括#，改变#不触发网页重载，但会改变浏览器的访问历史#是用来指导浏览器动作的，对服务器端完全无用，所以HTTP请求中不包括#。比如，访问下面的网址，http://www.example.com/index.html#print，浏览器实际发出的请求是这样的： GET /index.html HTTP/1.1 Host: www.example.com单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页。比如，从http://www.example.com/index.html#location1改为http://www.example.com/index.html#location2，浏览器不会重新向服务器 请求index.html。每次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮就可以回到上一个位置。这对于ajax应用程序特别有用，可以用不同的#值，表示不同的访问状态，然后向用户给出可以访问某个状态的链接。值得注意的是，上述规则对IE 6和IE 7不成立，它们不会因为#的改变而增加历史记录。 #后面的内容不会被发送到服务器端在第一个#后面出现的任何字符都会被浏览器解读为位置标识符，这些字符都不会被发送到服务器端。 比如，下面URL的原意是指定一个颜色值：http://www.example.com/?color=#fff，但是浏览器实际发出的请求是： GET /?color= HTTP/1.1 Host: www.example.com 可以通过javascript使用window.location.hash来改变#后面的值window.location.hash这个属性可以对URL中的#参数进行修改，基于这个原理，我们可以在不重载页面的前提下创造一条新的访问记录。除此之外，HTML 5新增了onhashchange事件，当#值发生变化时就会触发这个事件。 Google抓取#的机制默认情况下，Google的网络蜘蛛忽视URL的#部分。但Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用”#!”，Google会自动将其后面的内容转成查询字符串_escaped_fragment_的值。比如，Google发现新版twitter的URL：http://twitter.com/#!/username，就会自动抓取另一个URL：http://twitter.com/?_escaped_fragment_=/username。通过这种机制，Google就可以索引动态的Ajax内容。 &amp;&amp;是URL中指定的参数间的分隔符。 ??在URL中一般有两种作用： 连接作用：比如http://www.example.com/Show.asp?id=77&amp;nameid=2905210001&amp;page=1。 清除缓存：比如 http://www.example.com/index.html http://www.example.com/index.html?test123123 两个url打开的页面一样，但后面这个有问号，说明不调用缓存的内容，而是重新读取一个新地址。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我看过的那些书（计算机方面）]]></title>
    <url>%2F2016%2F05%2F11%2F%E6%88%91%E7%9C%8B%E8%BF%87%E7%9A%84%E9%82%A3%E4%BA%9B%E4%B9%A6%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%96%B9%E9%9D%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[记录自己读过的计算机方面的书籍，鉴于水平有限，各种书的简介只是自己的感受，详细的还需要参考网上的其他资料。 1、C++ Primer 中文版（第 5 版）介绍简介：C++的工具书，介绍的很全，字典类图书，不适合精读。 2、PHP和MySQL Web开发（原书第4版）介绍简介：PHP入门的好书，开始第一次读的是英文版的，后来有问题回看的时候看的中文，实在是没有体会到网上说的看原版书的好处，感觉还是中文的读的踏实。 3、细说PHP(精要版)介绍简介：细说PHP的精简版，重点突出很条理，感觉这本书跟上本提到的PHP和MySQL Web开发任选一本足矣。 4、Ajax、JavaScript和PHP编程导学 介绍简介：这本书是哈佛大学的公开课CS50里提到的一本书，比较简单，简单翻翻就行，如需深入了解还需要查阅有关书籍。 5、Linux系统命令己Shell脚本实践指南介绍简介：讲解的挺全面的，觉得学习Linux和shell，感觉还是动手来的快，对着这书撸一遍，应付面试差不多了。其他的深入还需要实践中碰到问题解决问题才能进一步提升吧。 6、数据结构与算法分析 C++描述（第3版）介绍简介：算法的经典书籍，无需解释，这书应该都绝版了，网上现在卖的都是第2版的C语言版，我也是翻了好久才淘到的，但应该差别不大。感觉算法很重要，尤其是在校招的时候，思想！基础！自己在校招之前的这段时间要重点放在这上面。这本书和《算法》要温习一下，然后刷LeetCode，提高自己的编程算法能力。 待看《算法》《深入理解计算机系统》]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求连续子向量的最大和]]></title>
    <url>%2F2016%2F04%2F14%2F%E6%B1%82%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%90%91%E9%87%8F%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%2F</url>
    <content type="text"><![CDATA[本问题来自于《编程珠玑》第八章。问题：输入是具有n个整数的向量，输出是输入向量的任何连续子向量中的最大和。 算法一立方算法，该算法需求出所有子序列的和，时间复杂度为$O(n^3)$。本算法对$max$进行了$n^3/2$次调用。 int maxSum1(vector&lt;int&gt; nums) { int maxsofar = 0, len = nums.size(); if(len == 0) { return 0; } else if(len &gt; 0) { for(int i=0; i&lt;len; i++) { for(int j=i; j&lt;len; j++) { int sum = 0; for(int k=i; k&lt;=j; k++) { sum += nums[k]; } maxsofar = max(maxsofar, sum); //求出所有子序列的和 } } if(maxsofar &gt; 0) { return maxsofar; } else { return 0; } } }算法二算法二都是通过固定的步数而不是算法一的$[j-i+1]$步内完成对$nums[i,j]$的求和，但根据在固定时间内计算总和时使用方法的不同分为了a、b两种算法，两者的时间复杂度都为$O(n^2)$。本算法对$max$进行了$n^2/2$次调用。a算法由$nums[i,j]$的总和与前面计算出的总和$nums[i,j-1]$密切相关可得。 int maxSum2a(vector&lt;int&gt; nums) { int maxsofar = 0, len = nums.size(); if(len == 0) { return 0; } else if(len &gt; 0) { for(int i=0; i&lt;len; i++) { int sum = 0; for(int j=i; j&lt;len; j++) { sum += nums[j]; maxsofar = max(maxsofar, sum); } } if(maxsofar &gt; 0) { return maxsofar; } else { return 0; } } } b算法是通过访问在循环执行前就已构建的数据结构来计算综合。cumarr中的第i个元素包含$nums[0,i]$中各个数的累加和，所以$nums[i,j]$中各个数的和可由$cumarr[j]-cumarr[i-1]$得到。 int maxSum2b(vector&lt;int&gt; nums) { int maxsofar = 0, len = nums.size(); int cumarr[len]; if(len == 0) { return 0; } else if (len &gt; 0) { cumarr[-1] = 0; for(int i=0; i&lt;len; i++) { cumarr[i] = cumarr[i-1] + nums[i]; } for(int i=0; i&lt;len; i++) { for(int j=i; j&lt;len; j++) { int sum = cumarr[j] - cumarr[i-1]; maxsofar = max(maxsofar, sum); } } if(maxsofar &gt; 0) { return maxsofar; } else { return 0; } } }算法三采用分治算法，将输入向量分为左、右两部分，分别计算左、右半部分的子序列和，再加上横跨左右两部分的最大连续子序列和，最后返回三个和中的最大值，该算法的时间复杂度为$O(nlogn)$。 本算法使用了对数的额外空间，其他算法仅使用了常熟的额外空间。 注：开始的时候以为for循环里只是求出了半截子序列的所有和，并没有对子序列里的任意连续子序列求和，仔细研读书本后，发现了是在return里的maxSum3里实现了递归。 int maxSum3(vector&lt;int&gt; nums, int l, int u) { if(l &gt; u) { return 0; } if(l == u) { return max(0, nums[1]); } int m = (l + u) / 2; int sum = 0; int lmax = sum; for(int i=m; i&gt;=1; i--) { sum += nums[i]; lmax = max(lmax, sum); } sum = 0; int rmax = sum; for(int j=m+1; j&lt;u; j++) { sum += nums[j]; rmax = max(rmax, sum); } return (lmax+rmax &gt;= maxSum3(nums, 1, m)) ? (lmax+rmax &gt;= maxSum3(nums, m+1, u) ? lmax+rmax : maxSum3(nums, m+1, u)) : (maxSum3(nums, 1, m) &gt;= maxSum3(nums, m+1, u) ? maxSum3(nums, 1, m) : maxSum3(nums, m+1, u)); }算法四该算法为扫描算法，从数组最左端开始扫描，一直到最右端，记下遇到的子序列的和的最大值。最大和的最大值为0，假设我们已经解决了$nums[0,i-1]$的问题，此处可以采用类似于分治法的思路，前i个元素中，子序列最大和要么在前$i-1$个元素中（我们将其存储在子啊$maxsofar$中），要么在其结束位置i处（我们将其存储在$maxendinghere$中），该算法的时间复杂度为$O(n)$。本算法对$max$进行了$2n$次调用，是实时的，一趟输入完毕它就计算出答案，也别适用于处理磁盘文件。 int maxSum4(vector&lt;int&gt; nums) { int maxsofar = 0, maxendinghere = 0, len = nums.size(); if(len == 0) { return 0; } else if(len &gt; 0) { for(int i=0; i&lt;len; i++) { maxendinghere = max(maxendinghere+nums[i], 0); maxsofar = max(maxsofar, maxendinghere); } return maxsofar; } }全部代码全部代码]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm，编程珠玑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode]]></title>
    <url>%2F2016%2F04%2F06%2FLeetCode%2F</url>
    <content type="text"><![CDATA[本文主要记载自己的刷LeetCode经历。 1. Two Sum题目 Approach #1使用两个for循环，时间复杂度为$O(n^2)$，空间复杂度为:$O(n1)$。 //Runtime:560 ms class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); vector&lt;int&gt; result; for(int i=0; i&lt;len; i++) { for(int j=i+1; j&lt;len;j++) { if(nums[i] + nums[j] == target) { result.push_back(i); result.push_back(j); return result; } } } } };Approach #2使用哈希函数组织的map，时间复杂度为$O(n)$，空间复杂度为:$O(n)$。 //Runtime: 16 ms class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { int len = nums.size(); vector&lt;int&gt; result; unordered_map&lt;int, int&gt; myMap; for(int i=0; i&lt;len; i++) { myMap[nums[i]] = i; } for(int i=0; i&lt;len; i++) { int complement = target - nums[i]; if(myMap.find(complement) != myMap.end() &amp;&amp; myMap[complement] != i) { result.push_back(i); result.push_back(myMap[complement]); return result; } } } };2. Add Two Numbers题目 Approach使用单向连边，注意点运算符“.”和箭头运算符“-&gt;”都可以用于访问成员，其中点运算获取类对象的一个成员，箭头运算获取指针指向对象的成员。时间复杂度为$O(max(m,n))$，空间复杂度为:$O(max(m,n))$。 //Runtime: 36 ms class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode dummy(0); ListNode* result = &amp;dummy; int cnt = 0, sum = 0, val = 0; while (l1 || l2) { sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + cnt; cnt = sum / 10; val = sum % 10; result-&gt;next = new ListNode(val); result = result-&gt;next; if(l1) l1 = l1-&gt;next; if(l2) l2 = l2-&gt;next; } if(cnt &gt; 0) { result-&gt;next = new ListNode(cnt); } return dummy.next; } };3. Longest Substring Without Repeating Characters题目 Approach使用哈希函数组织的map，关键字为字符，对应的值为字符在字符串中的位置。l = max(l, myMap[s[r]]+1)用于返回有重复字符时候的左边界位置。 tmmzuxt&emsp;s[l]是第二个m，s[r]是最后一个t，此时不需要更新l。 mmzuxtabt&emsp;s[l]是第二个m，s[r]是最后一个t，此时需要将l移动至a。 //Runtime: 56 ms class Solution { public: int lengthOfLongestSubstring(string s) { int len = s.size(); int l = 0, r = 0, res = 0; unordered_map&lt;char, int&gt; myMap; while(r &lt; len) { if(myMap.find(s[r]) != myMap.end()) { l = max(l, myMap[s[r]]+1); //返回有重复字符时候的左边界位置 } myMap[s[r]] = r; res = max(res, r-l+1); r++; } return res; } }; 6. ZigZag Conversion题目 Approachbasic_string&lt;&gt;有双重身份，一是代替传统的字符串，所以应该有strlen函数，给出相应的字符串长度；另一个身份是可以用作STL容器，所以要按照STL容器的惯例给出size()。本题的重点是要求出周期$2 * numRows - 2$,然后首行末行的循环周期都是此周期，中间行还需要进行单独计算。 //Runtime: 16 ms class Solution { public: string convert(string s, int numRows) { int len = s.size(); if(numRows &lt; 2){ return s; } string tmp = &quot;&quot;; int cnt = 2 * numRows - 2; for(int i=0; i&lt;numRows; i++) { for(int j=i; j&lt;len; j+=cnt) { tmp += s[j]; if(i&gt;0 &amp;&amp; i&lt;numRows-1){ //计算中间行的循环，以cnt为一个循环周期 int num = cnt + j - 2 * i; if(num &lt; len) { tmp += s[num]; } } } } return tmp; } };237. Delete Node in a Linked List题目 Approach时间复杂度和空间复杂度都为$O(1)$。 //Runtime: 16 ms class Solution { public: void deleteNode(ListNode* node) { node-&gt;val = node-&gt;next-&gt;val; node-&gt;next = node-&gt;next-&gt;next; } }; 328. Odd Even Linked List题目 Approach若链表非空，至少有一个元素，此时就可看出，while循环的终止条件使用even和even-&gt;next较合适。时间复杂度为$O(n)$，我们需要遍历n个节点；空间复杂度为:$O(1)$，我们所需要的只是4个指针。 //Runtime: 20 ms class Solution { public: ListNode* oddEvenList(ListNode* head) { if(head == NULL) return NULL; ListNode* odd = head; ListNode* even = head-&gt;next; ListNode* evenHead = even;; while(even &amp;&amp; even-&gt;next) { odd-&gt;next = even-&gt;next; odd = odd-&gt;next; even-&gt;next = odd-&gt;next; even = even-&gt;next; } odd-&gt;next = evenHead; return head; } };]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode，algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML网络协议]]></title>
    <url>%2F2016%2F03%2F29%2FHTML%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[本文主要简单的论述下计算机网络的大概结构，并重点讲解下自己对HTTP协议的理解。所有的因特网标准都是以RFC(Request For Comments)的形式在因特网上发表的,任何人都可以用电子邮件随时发表对某个文档的意见或建议。 计算机网络体系OSI的七层协议概念清楚，理论完整，但它复杂又不实用，在实际中我们广泛应用的是TCP/IP四层体系结构，但我们在学习计算机网络原理时，常采用五层协议的体系结构。五层协议是指应用层、运输层、网络层、数据链路层、物理层。 应用层直接为用户的应用进程(正在运行的程序)提供服务，该层协议有：HTTP、SMTP(电子邮件)、FTP等。 运输层主要负责为两个主机进程之间的通信提供服务，主要使用TCP(传输控制协议)、UDP(用户数据报协议)这两种协议。TCP是面向连接的、可靠的、有序的、速度慢的协议，常应用于传输大量数据的场合；UDP是无连接的、不可靠的、无序的、速度快的协议，提供尽最大努力交付，常应用于传输少量数据的场合。基于TCP的协议有：HTTP(80)/HTTPS(443)，Telnet(23)，FTP(21)，SMTP(25)。基于UDP的协议有：DHCP(67)，DNS(53)。 网络层负责为分组交换网上的不同主机提供通信服务，并且要选择合适的路由，使源主机运输层所传下来的分组能够通过网络中的路由器找到目的主机。在TCP/IP体系中，网络层使用IP协议。该层的协议有地址解析协议ARP、逆地址解析协议RARP、网际控制报文协议ICMP、虚拟专用网VPN、网络地址转换NAT等。 数据链路层负责在相邻两个节点之间传送数据时，将网络层交下来的IP数据报组装成帧(每一帧包括数据和必要的控制信息)，在节点间的链路上透明地传送帧中的数据。 物理层上传送数据的单位是比特，它的任务就是透明的传送比特流。 HTTP协议在这里简单的说一下客户端访问服务器的工作过程。客户端和服务器之间使用HTTP协议建立TCP连接(三次握手)，然后客户端发送HTTP请求报文，服务器返回HTTP响应报文，完成访问后，释放TCP连接(四次挥手)。HTTP的请求报文和响应报文的区别在于请求报文的开始行叫请求行，响应报文的开始行叫状态行。请求行包括方法、请求资源的URL以及HTTP版本。状态行包括HTTP版本、状态码以及解释状态码的简单短语。在这里解释下状态码的含义： 1xx:通知信息。 2xx:成功。 3xx:重定向。 301:所请求的页面已经转移至新的url 302:所请求的页面已经临时转移至新的url 4xx:客户机错误。 401:未授权 403:所请求的页面被禁止访问 404:服务器无法找到被请求的页面 5xx:服务器错误。 500:请求未完成，服务器遇到不可知的问题 502:请求未完成，服务器从上游服务器收到一个无效的响应 504:网关超时Cookie &amp; SessionHTTP是无状态协议，它没有一个内建机制来维护两个事务之间的状态，但是网站在区别不同用户访问的时候需要进行会话跟踪，所以产生了Cookie和Session。Cookie是通过HTTP请求的头部信息传回服务器的，Session变量的值保存在服务器端(文件/数据库/缓存中)。当用户访问某个使用Cookie的网站时，该网站的服务器就为此用户产生一个唯一的识别码，并以此作为索引在服务器的后端数据库中产生一个项目，接着在给该用户的HTTP响应报文中添加一个叫Set-cookie的首部行（首部字段名是”Set-cookie”，字段值是”识别码”）。当用户收到响应时，他所使用的浏览器就在它管理的特定Cookie文件中添加一行，包括这个服务器的主机名和识别码，当用户继续访问该网站时，每发送一个HTTP请求报文，其浏览器就会从Cookie文件中取出这个网站的识别码，并放到HTTP请求报文中的Cookie首部行中，这样网站就能跟踪到该用户在该网站的活动。Cookie将数据存储在客户端，但Cookie相对不太安全，单个Cookie的值最大只能存储4k，每次请求都要进行网络传输，占用带宽。Session将用户的会话数据存储在服务端，没有大小限制，通过一个session_id进行用户识别，PHP默认情况下session id是通过Cookie来保存的，因此从某种程度上来说，Session依赖于Cookie，但这不是绝对的，只要能将session id传递到服务端进行识别的机制都可以实现session。如果客户端禁用Cookie,可以使用URL重写，也可以指定通过GET方式或者POST方式把session id传到服务器。 三次握手 &amp; 四次挥手TCP链接的建立采用客户服务器方式，主动发起连接建立的应用进程叫客户，被动等待连接建立的应用进程叫服务器。 三次握手 第一次握手：客户端将标志位SYN置为1，选择一个初始序号seq=x(随机产生)，并将该数据包发送给服务器，客户端进入SYN-SENT状态，等待服务器确认。 第二次握手：服务器收到数据包后由标志位SYN=1知道客户端请求建立连接，服务端将标志位SYN和ACK都置为1，确认号ack=x+1(ack为前一个的seq+1)，也选择一个初始序号seq=y，并将该数据包发送给客户端以确认连接请求，服务器进入SYN-RCVD状态。 第三次握手：客户端收到确认后，确认ACK为1，ack是x+1，如果正确则将标志位ACK置为1，ack=y+1，自己的序号seq=x+1(如果ACK报文段不携带数据则不消耗序号)并将该数据包发送给服务器，服务器检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器进入ESTABLISHED状态，完成三次握手，随后客户端与服务器之间可以开始传输数据了。 四次挥手 第一次挥手：客户端把连接释放报文段首部的FIN置1,序号seq=u(等于前面已传送过的数据的最后一个字节的序号加1),用来关闭客户端到服务器的数据传送，客户端进入FIN-WAIT-1状态。 第二次挥手：服务器收到FIN后，发送一个ACK给客户端，确认号为ack=u+1，seq=v,服务器进入CLOSE-WAIT状态(A到B关闭，B到A仍未关闭)。A收到B的确认后，进入Fin-WAIT-2状态。 第三次挥手：服务器发送一个FIN，序号seq=w，ack=u+1,用来关闭服务器到客户端的数据传送，服务器进入LAST-ACK状态。 第四次挥手：客户端收到FIN后，在确认报文段中使ACK=1，ack=w+1，seq=u+1,然后进入TIME-WAIT状态(2MSL，MSL为最长报文段寿命)，服务器进入CLOSED状态，完成四次挥手。 TIME-WAIT状态必须等待2MSL的原因： 为了保证A发送的最后一个ACK报文段能够到达B，若丢失，B超时重传FIN+ACK报文段。 防止已失效的报文段出现在本连接中，A发送完最后一个ACK报文段后，再经过2MSL，可以使本连接持续的时间内所长生的所有报文段都从网络中消失。 HTTP方法HTTP请求方法总共有八种。HTTP1.0定义了三种请求方法：GET，POST和HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS，PUT，DELETE，TRACE和CONNECT方法。 GETGET用于从指定的资源请求数据，是http的默认请求方式，一般用来获取数据，传输的数据经过url编码后放在路径?之后，多个键值对通过&amp;连接，另外get的传输长度一般不推荐超过255个字节。它一般被视为安全方法，因为它仅用来获取数据而不会对服务器有其他改动。 安全方法像HEAD、GET、OPTIONS和TRACE这几种http方法是被认为是“安全的”，这意味着它们只会进行数据获取而不会修改服务器的状态，不会产生负面影响，比如记录日志、创建缓存或者创建其他统计信息。像POST、PUT、DELETE和PATCH等方法有可能产生副作用。网络爬虫等一般不会使用这些方式(注:搜索引擎的暗网抓取可能会使用这些方法)。 尽管GET方法是一般被视为“安全的”，但如果在实际使用中没有做任何设置，比如可以无限制的抓取等情况，也会导致一些不可预料的问题，比如web缓存或者搜索引擎问题。 POSTPOST用于向指定的资源提交要被处理的数据。数据被包含在请求体中，可能会导致新的资源的建立或已有资源的修改。 为什么一些请求会使用POST提交数据? GET请求数据都可以在URL中看到，不应在处理敏感数据时使用，而POST请求数据在URL中是不可见的。 GET提交的数据都会有长度限制(URL的最大长度是2048个字符)，POST没有长度限制。 一般规范，GET用来获取数据，POST用来修改数据。 GET请求可以被缓存，会被保留在浏览器的历史记录中，而POST请求不能被缓存，也不会被保留在浏览器的历史记录中。 GET请求提交的数据放置在HTTP请求协议头中，而POST提交的数据则放在实体数据中。 其他请求方法 HEAD 与 GET 相同，但只返回HTTP报头，不返回文档主体。 PUT 从客户端向服务器传送数据取代指定的文档内容，如果存在则修改内容，否则创建新内容。 DELETE 请求服务器删除指定的页面。 TRACE 返回接受到的请求，用来查看数据经过中间服务器时发生了哪些变动。 OPTIONS 返回服务器支持的所有HTTP方法。 CONNECT 要求使用SSL和TLS进行TCP通信。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的遍历]]></title>
    <url>%2F2016%2F03%2F26%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[所谓遍历(Traversal)是指沿着某条搜索路线，依次对树中每个结点均做一次且仅做一次访问。遍历是二叉树最重要的运算之一，是二叉树上进行其它运算的基础。 根据访问结点操作发生位置命名： 前序遍历(Preorder Traversal)，访问根结点的操作发生在遍历其左右子树之前。 中序遍历(Inorder Traversal)，访问根结点的操作发生在遍历其左右子树之中。 后序遍历(Postorder Traversal)，访问根结点的操作发生在遍历其左右子树之后。 层序遍历(Level-order Traversal)，所有深度为d的结点要在深度为d+1的节点之前处理。由于它用的较少，所以本文不对它进行讨论。 注：由于先左后右和先右后左对称，故本文只讨论先左后右的三种次序。 二叉树节点定义二叉树节点使用以下数据结构进行表示，包括关键字、左儿子、右儿子属性和一个带默认参数的构造函数。 struct TreeNode { public: int val; TreeNode *left, *right; TreeNode(int v = 0, TreeNode *l = NULL, TreeNode *r = NULL) :val(v), left(l), right(r) { } };二叉树的遍历二叉树遍历的实现方式主要有三种：递归遍历，非递归遍历和Morris遍历。 递归遍历递归遍历的实现非常简单，按照遍历的次序，对当前结点分别调用左子树和右子树即可。此时每个结点只需遍历一次，故时间复杂度为O(n)。最差情况下递归调用的深度为O(n)，所以空间复杂度为O(n)。 前序遍历void preOrder(TreeNode *root) { if(root == NULL) { return; } cout &lt;&lt; root-&gt;val &lt;&lt;endl; preOrder(root-&gt;left); preOrder(root-&gt;right); } /*void函数如果想在它们的中间位置提前退出，可以使用return语句，此时return有点类似break； 只要函数的返回类型不是void，则每条return语句必须返回一个值。*/ 中序遍历void inOrder(TreeNode *root) { if(root == NULL) { return; } inOrder(root-&gt;left); cout &lt;&lt; root-&gt;val &lt;&lt;endl; inOrder(root-&gt;right); }后序遍历void postOrder(TreeNode *root) { if(root == NULL) { return; } postOrder(root-&gt;left); postOrder(root-&gt;right); cout &lt;&lt; root-&gt;val &lt;&lt;endl; }非递归遍历递归算法的本质是利用函数的调用栈进行，实际上我们可以自行使用栈来进行模拟，实现二叉树遍历的非递归实现。此时每个结点只需遍历一次，故时间复杂度为O(n)，空间复杂度为O(h),h为二叉树的高度。 前序遍历首先把根节点入栈，然后在每次循环中执行以下操作： 此时栈顶元素即为当前的根节点，弹出并打印当前的根节点； 把当前根节点的右儿子入栈； 把当前根节点的左儿子入栈。 void preOrder2(TreeNode *root) { if(root == NULL) { return; } stack&lt;TreeNode *&gt; stk; stk.push(root); while(!stk.empty()) { TreeNode *pNode = stk.top(); stk.pop(); cout &lt;&lt; pNode-&gt;val &lt;&lt; endl; if(pNode-&gt;left) { stk.push(pNode-&gt;left); } if(pNode-&gt;right) { stk.push(pNode-&gt;right); } } } 中序遍历 初始化一个二叉树结点pNode指向根结点； 若pNode非空，那么就把pNode入栈，并把pNode变为其左儿子，直到最左边的结点； 若pNode为空，弹出栈顶的结点，并访问该结点，将pNode指向其右儿子。 void inOrder2(TreeNode *root) { if(root == NULL) { return; } stack&lt;TreeNode *&gt; stk; TreeNode *pNode = root; while(pNode || !stk.empty()) { if(pNode) { stk.push(pNode); pNode = pNode-&gt;left; } else { pNode = stk.top(); stk.pop(); cout &lt;&lt; pNode-&gt;val &lt;&lt; endl; pNode = pNode-&gt;right; } } } 后序遍历因为后序遍历的顺序是：左子树-&gt;右子树-&gt;根节点，于是我们在前序遍历的代码中，当访问完当前节点后，先把当前节点的左子树入栈，再把右子树入栈，这样最终得到的顺序为：根节点-&gt;右子树-&gt;左子树，刚好是后序遍历倒过来的版本，于是把这个结果做一次翻转即为真正的后序遍历。而翻转可以通过使用另外一个栈简单完成，这样的代价是需要两个栈，但就复杂度而言，空间复杂度仍然是O(h)。 void postOrder2(TreeNode *root) { if(root == NULL) { return; } stack&lt;TreeNode *&gt; stk1,stk2; stk1.push(root); while(!stk1.empty()) { TreeNode *pNode = stk1.top(); stk1.pop(); stk2.push(pNode); if(pNode-&gt;right) { stk1.push(pNode-&gt;right); } if(pNode-&gt;left) { stk1.push(pNode-&gt;left); } } while(!stk2.empty()) { cout &lt;&lt; stk2.top()-&gt;val &lt;&lt; endl; stk2.pop(); } } Morris遍历Morris遍历的神奇之处在于它是非递归的算法，且不需要额外的O(h)的空间，而且复杂度仍然是线性的。这样的算法最关键的问题是当访问完一棵子树后，如何回到其对于的根节点再继续访问右子树呢？Morris是通过修改二叉树某些节点的指针来做到的。 中序遍历按照定义，在中序遍历中，对于一棵以root为根的二叉树，当访问完root的前驱节点后，需要回到root节点进行访问，然后再到root的右儿子进行访问。于是我们可以每次访问到一棵子树时，找到它的前驱节点，把前驱节点的右儿子变为当前的根节点root，这样当遍历完前驱节点后，可以顺着这个右儿子回到根节点root。但问题是修改了该前驱节点的右儿子后什么时候再改回来呢？ 当第一次访问以root为根的子树时，找到它的前驱pre，此时pre的右儿子必定为空，于是把这个右儿子设置为root，以便以后根据这个指针回到root节点。 当第二次回到以root为根的子树时，再找到它的前驱pre，此时pre的右儿子已经被设置成了当前的root，这时把该右儿子重新设置成NULL，然后继续进行root的右儿子的遍历。于是完成了指针的修改。 在这样的情景下，寻找当前节点的前驱节点时，不仅需要判断其是否有右儿子，而且还要判断右儿子是否为当前的root节点，跟普通情况下的寻址前驱节点稍微多了一个条件。由于在每次遍历一个节点的时候都需要寻找其前驱节点，而寻找前驱节点的时间一般与树的高度相关，这样看上去算法的复杂度应该为O(nlogn)才对。但由于其只需要对有左儿子的节点才寻找前驱，于是所有寻找前驱时走过的路加起来至多为一棵树的节点数，例如在下文的例子中，只需要对以下节点寻找前驱： 4 / \ 2 6 / \ / \ 1 3 5 7 节点4：寻找路径为：2-3 节点2：寻找路径为：1 节点6：寻找路径为：5 于是寻找前驱加上遍历的运算量之和至多为2*n，n为节点个数，于是算法的复杂度为仍然为O(n)。 void inOrder3(TreeNode *root) { if(root == NULL) { return; } TreeNode *pNode = root; while(pNode) { if(pNode-&gt;left == NULL) { cout &lt;&lt; pNode-&gt;val &lt;&lt; endl; pNode = pNode-&gt;right; } else { TreeNode *pPre = pNode-&gt;left; while(pPre-&gt;right != NULL &amp;&amp; pPre-&gt;right != pNode) { pPre = pPre-&gt;right; } if(pPre-&gt;right == NULL) { pPre-&gt;right = pNode; pNode = pNode-&gt;left; } else { pPre-&gt;right = NULL; cout &lt;&lt; pNode-&gt;val &lt;&lt; endl; pNode = pNode-&gt;right; } } } }前序遍历前序遍历和中序遍历类似，只是在遍历过程中访问节点的顺序稍有不同。即在第一次访问一棵子树时，就要先对根节点进行访问，于是cout输出语句被放到了if判断中第一次访问的分支中。 void preOrder3(TreeNode *root) { if(root == NULL) { return; } TreeNode *pNode = root; while(pNode) { if(pNode-&gt;left == NULL) { cout &lt;&lt; pNode-&gt;val &lt;&lt; endl; pNode = pNode-&gt;right; } else { TreeNode *pPre = pNode-&gt;left; while(pPre-&gt;right &amp;&amp; pPre-&gt;right != pNode) { pPre = pPre-&gt;right; } if(pPre-&gt;right == NULL) { pPre-&gt;right = pNode; cout &lt;&lt; pNode-&gt;val &lt;&lt; endl; //先输出左结点 pNode = pNode-&gt;left; } else { pPre-&gt;right = NULL; pNode = pNode-&gt;right; } } } }后序遍历后序遍历稍微复杂，但其遍历的基本顺序也是和前/中序遍历类似，只是在打印的时候做了一个翻转。考虑下文例子中的后序遍历结果：1 3 2 5 7 6 4。其可以这样进行拆分并进行解释： 4 / \ 2 6 / \ / \ 1 3 5 7 1：最左下角的结果节点 3 2：节点2、3的倒序 5：右儿子的最左下角的节点 7 6 4：右边一列节点4、6、7的倒序 于是我们可以在中序遍历过程中，当第二次访问到一个节点时，把它的左儿子到它的前驱节点的路径上的节点进行翻转打印，即可得到后序遍历的结果。但这样的话根节点到最右下角那一列会访问不到，增加一个辅助节点作为新的根节点，把原有根节点作为其左儿子即可。 void reverse(TreeNode *p1, TreeNode *p2) { if(p1 == p2) return; TreeNode *x = p1; TreeNode *y = p1-&gt;right; while(true) { TreeNode *temp = y-&gt;right; y-&gt;right = x; x = y; y = temp; if(x == p2) break; } } void printReverse(TreeNode *p1, TreeNode *p2) { reverse(p1, p2); TreeNode *pNode = p2; while(true) { cout &lt;&lt; pNode-&gt;val &lt;&lt; endl; if(pNode == p1) break; pNode = pNode-&gt;right; } reverse(p2, p1); } void postOrder3(TreeNode *root) { if(root == NULL) { return; } TreeNode *dummy = new TreeNode(-1); dummy-&gt;left = root; TreeNode *pNode = dummy; while(pNode) { if(pNode-&gt;left == NULL) pNode = pNode-&gt;right; else { TreeNode *pPrev = pNode-&gt;left; while(pPrev-&gt;right &amp;&amp; pPrev-&gt;right != pNode){ pPrev = pPrev-&gt;right; } if(pPrev-&gt;right == NULL) { pPrev-&gt;right = pNode; pNode = pNode-&gt;left; } else { printReverse(pNode-&gt;left, pPrev); pPrev-&gt;right = NULL; pNode = pNode-&gt;right; } } } }代码测试我们对以下简单的二叉树进行测试。 4 / \ 2 6 / \ / \ 1 3 5 7 测试代码 int main() { TreeNode a1(1), a3(3), a5(5), a7(7); TreeNode a2(2, &amp;a1, &amp;a3), a6(6, &amp;a5, &amp;a7); TreeNode a4(4, &amp;a2, &amp;a6); //前序遍历：4 2 1 3 6 5 7 5 preOrder(&amp;a4); preOrder2(&amp;a4); preOrder3(&amp;a4); cout &lt;&lt; endl; //中序遍历：1 2 3 4 5 6 7 inOrder(&amp;a4); inOrder2(&amp;a4); inOrder3(&amp;a4); cout &lt;&lt; endl; //后序遍历：1 3 2 5 7 6 4 postOrder(&amp;a4); postOrder2(&amp;a4); postOrder3(&amp;a4); }参考链接：&emsp;&emsp;二叉树遍历&emsp;&emsp;二叉树遍历（递归、非递归、Morris遍历）&emsp;&emsp;二叉树的三种遍历方式]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1006]]></title>
    <url>%2F2016%2F03%2F08%2FPOJ%201006%20%2F</url>
    <content type="text"><![CDATA[POJ 1006题目分析：依照中国剩余定理解题，关于该定理的分析可参考POJ1006: 中国剩余定理的完美演绎。接下来结合本题进行分析。 首先，$n_1 % 23 = p， n_2 % 28 = e , n_3 % 33 = i$。 根据公式$ a%b=c, (a+k \ast b)%b=c $得： $$ \begin{aligned} (n_1+n_2+n_3) % 23 = p,n_2和n_3必须是23的倍数 \ (n_1+n_2+n_3) % 28 = e,n_1和n_3必须是28的倍数 \ (n_1+n_2+n_3) % 33 = i,n_1和n_2必须是33的倍数 \end{aligned} $$ 进而得到，$ n_1是28和33的公倍数,n_2是23和33的公倍数,n_3是23和28的公倍数 $。 再根据公式$ a%b=c, a \ast k%b=k \ast c $得 $$ \begin{aligned} n_1 = 28 \ast 33 \ast l_1,n_1%23=1 \ n_2 = 23 \ast 33 \ast l_2,n_2%28=1 \ n_1 = 23 \ast 28 \ast l_3,n_3%33=1 \end{aligned} $$ $ l_1,l_2,l_3 $最小为$ l_1=6,l_2=19,l_3=2 $,得到对应的$ n_1=5544,n_2=14421,n_3=1288 $ 需要注意的是，$ n_1=5544,n_2=14421,n_3=1288 $并只是问题的一个解，不是最小解，最小解为$ (n_1 \ast p+n_2 \ast e+n_3 \ast i) % (23 \ast 28 \ast 33) = (n+d) $ 所以有$ n=（5544 \ast p+14421 \ast e+1288 \ast i-d）%21252 $ 本题所求的是最小整数解，为了避免n为负，最后结果为$ n=（5544 \ast p+14421 \ast e+1288 \ast i-d+21252）%21252 $。 /************************************* Author: Wang Pengzhuang Date:2016-03-08 Email: wpzhuang@gmail.com Description: 求最大生理周期 **************************************/ #include&lt;iostream&gt; using namespace std; int getMax(int a,int b,int c){ int m,n=0; for(m=1; n!=1; m++){ n=a*b*m%c; } return a*b*(m-1); } int main(){ int p, e, i, d, n, cnt=1; while(cin&gt;&gt;p&gt;&gt;e&gt;&gt;i&gt;&gt;d){ if(p==-1 &amp;&amp; e==-1 &amp;&amp; i==-1 &amp;&amp; d==-1){ break; } n = (getMax(28,33,23)*p + getMax(23,33,28)*e + getMax(23,28,33)*i+21252-d)%21252; if(n==0){ n=21252; } cout &lt;&lt; &quot;Case &quot; &lt;&lt; cnt &lt;&lt; &quot;: &quot; &lt;&lt; &quot;the next triple peak occurs in &quot; &lt;&lt; n &lt;&lt; &quot; days.&quot; &lt;&lt; endl; cnt++; } }]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell笔记]]></title>
    <url>%2F2016%2F03%2F03%2Fshell%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Shell在用户和计算机硬件之间起翻译作用,Shell编程的目的是简化管理操作,它是一种弱类型语言，是用C语言编写的程序。开头必须是#!/bin/bash,其中#!告诉系统其后路径所指定的程序即是解释此脚本文件的Shell程序。 Bash变量&emsp;&emsp;变量名必须以字母下划线开头，中间只能有字母、下划线和数字组成,默认类型都是字符串型，Bash只支持一维数组。&emsp;&emsp;变量分类——用户自定义变量、环境变量、预定义变量和位置参数变量。 &emsp;&emsp;用户自定义变量是局部变量，等号两边不能有空格，如果变量值有空格，需要加双引号,调用前需要加$。 &emsp;&emsp;环境变量是全局变量,PATH（系统查找命令的路径）, locale（当前语系查询）。&emsp;&emsp; 预定义变量：$?最后一次执行的命令的返回状态,$$当前进程的进程号(PID),$!后台进行的最后一个进程的进程号(PID)&emsp;&emsp;位置参数变量:$n代表参数位置,$*看成整体, $@分别对待, $#返回变量个数。 Shell运算符&emsp;&emsp;Shell运算符分为算数运算符、关系运算符、布尔运算符、字符串运算符、文件测试运算符。 算数运算符:原生bash不支持简单的数学运算，但是可以通过其他命令来实现。 awk和expr，expr最常用，weight=`expr 1+1`。 let表示数学运算，let “weight+1” or let “weight=$weight+1”。 (())——运算符, ((weight+1)) or ((weight=$weight+1))。 $[ ]将中括号内的表达式作为数学运算先计算结果再输出,Weight=$[$weight+1]。 关系运算符:只支持数字，不支持字符串，除非字符串的值是数字。 布尔运算符: !，-o，-a。 字符串运算符 文件测试运算符：用于检测Unix文件的各种属性。参考：Shell编程 Shell函数&emsp;&emsp;在Shell中的所有函数在使用前必须定义，这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 [function] funname [()] { action; [return int;] }注：$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 Shell输入/输出重定向&emsp;&emsp;0是标准输入（STDIN），1是标准输出（STDOUT），2是标准错误输出（STDERR）。 &gt; 将命令输出写入文件 &gt;&gt; 将命令追加到文件 &amp;&gt;&gt; 将正确错误命令都可以追加到文件里 命令&gt;&gt;文件1 2&gt;&gt;文件2 正确命令写入文件1，错误写入文件2 Shell正则表达式&emsp;&emsp;正则表达式主要用于字符串的模式分割、匹配、查找及替换操作，正则是包含匹配，通配符用来匹配符合条件的文件名，通配符是完全匹配。 \* 匹配任意内容 ？ 匹配任意一个内容 [] 匹配中括号中的一个字符 \d 任意一个十进制数字 \s 任意一个空白字符 \w 任意一个数字、字母、下划线 ^ 在[]外代表开头，在[]内代表取反 *={0,}, +={1,},?={0,1}]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>shell linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL笔记]]></title>
    <url>%2F2016%2F02%2F28%2FMySQL%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;&emsp;&emsp;这些知识点补全，很碎，主要是自己平常不清楚的或者易混淆的。 mysql -h 主机名 -u 用户名 -p -h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略 -u : 所要登录的用户名 -p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项 MySQL语句以分号为语句的结束, 若在语句结尾不添加分号时, 命令提示符会以 -&gt; 提示你继续输入(有个别特例, 但加分号是一定不会错的)。 对于一些较长的语句在命令提示符下可能容易输错, 因此我们可以通过任何文本编辑器将语句输入好后保存为.sql 的文件中, 通过命令提示符下的文件重定向执行执行该脚本。打开命令提示符, 输入:mysql -D samp_db -u root -p &lt; createtable.sql提示: 如果连接远程主机请加上 -h 指令;createtable.sql文件若不在当前工作目录下需指定文件的完整路径 A=B or A=C or A=D A in (‘B’,’C’,’D’)A!=B and A!=C and A!=D A not in(’B’,’C’,’D’) SQL 语句对大小写不敏感。 如果要插入的字段是auto_increment属性，那么在insert的时候values里要么不注明该字段，要么设为null。 CREATE TABLE Persons ( P_Id int NOT NULL AUTO_INCREMENT, LastName varchar(255) NOT NULL, FirstName varchar(255), PRIMARY KEY (P_Id) ) INSERT INTO Persons (FirstName,LastName) VALUES (&#39;Bill&#39;,&#39;Gates&#39;) INSERT INTO Persons VALUES (null，&#39;Bill&#39;,&#39;Gates&#39;) MySQL的反引号是为了区分MySQL的保留字与普通字符而引入的符号，如果字段值是字符或字符串，则要加引号。 可从以下几个方面进行优化MySQL(重要性依次降低，成本依次增加） SQL及索引 数据表结构 系统配置 硬件 具体措施： max加索引 count分开查 子查询优化为join limit限制查询：避免过多的扫描 使用有索引的列或主键进行order by操作 记录上次返回的主键，在下次查询时使用主键过滤 索引 在where、group by、order by、on从句中出现的列 索引字段越小越好 离散度大的列放到联合索引的前面 索引的维护及优化——删除重复己冗余的索引 选择合适的数据类型 数据结构优化：表的范式化和反范式化。符合第三范式，要求数据表中不存在非关键字段对任何候选关键字段的传递函数依赖。 数据库结构优化：表的垂直拆分和水平拆分。 系统配置优化 服务器硬件优化 SQL语言包含四个部分： 数据定义语言(DDL):CREATE DROP ALTER 数据操作语言(DML):INSERT UPDATE DELETE 数据查询语言(DQL):SELECT 数据控制语言(DCL):GRANT REVOKE COMMIT ROLLBACK 一些典型的SQL语法 INSERT INTO 表名 [(字段名1，字段名2，...，字段名n)] VALUES (&apos;值1&apos;，&apos;值2&apos;，...,&apos;值n&apos;); UPDATE 表名 SET 字段名=表达式[,...] [WHERE 条件] [ORDER BY 字段] [LIMIT 行数]； SELECT [ALL|DISTINCT] {*|table.*|[table.]field1[AS alias1][,table.|\field2[AS alias2][,...]]} FROM tableexpresion[,...][IN externaldatabase] [WHERE] [GROUP BY] [HAVING] [ORDER BY] [LIMIT count]; COUNT() COUNT（*）返回找到的记录行数 SUM() AVG() MAX() MIN()]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim配置及常用操作、Linux常用操作]]></title>
    <url>%2F2016%2F02%2F24%2FVim%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[记录使用vim和linux的心得。 Vim配置syntax enable &quot;语法高亮 syntax on &quot;允许用指定语法高亮配色方案替换默认方案 set number &quot;显示行号 set autoindent &quot;使用自动对齐，把当前行的对齐格式应用到下一行 set laststatus=2 &quot;总是显示状态栏 set cursorline &quot;高亮显示当前行 set hlsearch &quot;高亮显示搜索结果 filetype indent on &quot;自适应不同语言的智能缩进 set tabstop=4 set shiftwidth=4 set mouse=a &quot;光标跟随鼠标移动 &quot;Vundle 配置 &quot;filetype on set nocompatible &quot; be iMproved, required filetype off &quot; required &quot; set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() &quot;YouCompleteMe 配置] 参考：wsmmsh.github.io/2016/02/02/Centos%E5%AE%89%E8%A3%85YouCompleteMe/ Vim常用操作 yy——复制游标所在行整行 2yy、y2y——复制两行 ggyG——全选复制 dd——剪切游标所在行整行 2dd、d2d——剪切两行 p——在当前光标处下面粘贴内容 P——在当前光标处上面粘贴内容 #——往后查找并高亮显示所有光标所在处单词，*是往前查找 :sp——在当前窗口垂直打开新文件 :vsp——在当前窗口垂直打开新文件 CTRL+W+H/J——多窗口切换 /word——向光标之下寻找一个名称为 word 的字符串。 ？word——向光标之上寻找一个字符串名称为 word 的字符串。 u——复原前一个动作。 CTRL+r——重做上一个动作。 . ——不要怀疑！这就是小数点！意思是重复前一个动作的意思。 Linux常用命令 增：mkdir、vim、touch、systemctl、cd、tar、gzip 删：rm、kill 改：mv、cp、chmod、chgrp、chown 查：cat、ls、ps、history、locate、which、whereis、find、who、pwd、man、grep]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos安装YouCompleteMe]]></title>
    <url>%2F2016%2F02%2F02%2FCentos%E5%AE%89%E8%A3%85YouCompleteMe%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;折腾了一天，总算把YCM装上了，在这里进行一下总结。安装分为快速安装和完整安装，官方推荐完整安装，但大家可以先试一下快速安装，如果不成功再进行完整安装。需要注意的是YouCompleteMe要求Vim版本大于等于7.3，在进行安装前大家需要确定这点。 安装YouCompleteMe&emsp;&emsp;首先确定YCM的安装方式，分为两种：使用Vundle和使用源代码安装,注意此步仅仅相当于安装了一个空壳，并不能使用YCM，还需要后续步骤。 (1)使用Vundle安装&emsp;&emsp;Vundle是Vim的一款管理插件的插件，安装详细请参照Vundle官方网站。注意把官网下方的配置文件放入你自己的.vimrc里，可以把不需要的插件去除。 在你的vimrc中添加Plugin &#39;Valloric/YouCompleteMe&#39;，然后执行:PluginInstall。 注：使用Vundle更新YCM的时候可能需要重新编译，引用来自官方的提示： YCM is a plugin with a compiled component. If you update YCM using Vundle and the ycm_support_libs library APIs have changed (happens rarely), YCM will notify you to recompile it. You should then rerun the install process. (2)使用源码安装#下载YouCompleteMe源码 git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/bundle/YouCompleteMe cd YouCompleteMe/ #获取YCM的依赖包 git submodule update --init --recursive #然后在在vimrc文件中加入 Bundle &apos;Valloric/YouCompleteMe&apos; 快速安装此处给出支持C-family的命令，其他的选项见参考文档。 cd ~/.vim/bundle/YouCompleteMe ./install.py --clang-completer之后会看到提示安装成功。参考：Fedora Linux x64 Installation 完整安装1、安装svn、cmake&emsp;&emsp;sudo yum install svn 因为centos直接使用yum安装的版本号为2.8.11，而llvm源码编译安装不再支持make，需要的cmake要求最低为2.8.12，所以需要源码安装cmake。 CMake 2.8.12.2 or higher is required. You are running version 2.8.11 (1)下载最新源码 https://cmake.org/download/ 进入文件下载目录 tar -xzvf cmake-3.4.3.tar.gz (2)进入到cmake文件夹中执行引导命令(此时会检查gcc ,gcc-c++是否安装，如果没有请先安装) cd cmake-3.4.3 yum install gcc yum install gcc-c++ ./bootstrap (3)安装 make make install (4)添加环境变量，使其永久有效： vim /etc/profile 在文件末尾追加以下两行代码： PATH=/usr/local/cmake/bin:$PATH export PATH然后执行以下操作： source /etc/profile //使修改生效 echo $PATH //查看PATH值验证cmake是否安装成功： [root@localhost cmake-3.4.3]# cmake -version cmake version 3.4.3 CMake suite maintained and supported by Kitware(kitware.com/cmake). 参考：Getting Started with the LLVM System&emsp;&emsp;&emsp;Building LLVM with CMake 2、新建目录，编译安装llvm-clang#Checkout LLVM: mkdir ~/llvm-clang cd ~/llvm-clang svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm #Checkout Clang: cd llvm/tools svn co http://llvm.org/svn/llvm-project/cfe/trunk clang #Checkout extra Clang Tools: cd /clang/tools svn co http://llvm.org/svn/llvm-project/clang-tools-extra/trunk extra #Checkout Compiler-RT: cd ~/llvm-clang/llvm/projects svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt #Checkout Libomp (required for OpenMP support): svn co http://llvm.org/svn/llvm-project/openmp/trunk openmp #cd where you want to build llvm cd ~/llvm-clang mkdir llvm-build(in-tree build is not supported) cd llvm-build cmake -G &quot;Unix Makefiles&quot; ../llvm make参考：Getting Started: Building and Running Clang&emsp;&emsp;&emsp;Getting Started with the LLVM System 3、安装Python如果系统没有装有python及其有关库，则需安装： #安装python `sudo yum install python` #安装python所需要的库 `sudo yum install python-devel`4、编译YCM需要的ycm_support_libs库创建一个文件夹来存放编译文件 cd ~ mkdir ycm_build cd ycm_build 下一步生成makefile，这一步很重要，有点复杂。 如果不需要C-falmily的语义支持：在ycm_build目录下执行： cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp 如果需要C-falmily的语义支持，分三种情况： (1)假如你从llvm的官网下载了LLVM+Clang，然后解压到：/ycm_temp/llvm_root_dir （该目录下有 bin, lib, include 等文件夹），然后执行： `cmake -G “Unix Makefiles” -DPATH_TO_LLVM_ROOT=/ycm_temp/llvm_root_dir ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp(2)如果想用系统的libclang：cmake -G “Unix Makefiles” -DUSE_SYSTEM_LIBCLANG=ON ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp(3)如果想用自己编译的libclang：cmake -G “Unix Makefiles” -DEXTERNAL_LIBCLANG_PATH=/path/to/libclang.so ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp其中/path/to/libclang.so这部分填入你自己的路径。 然后执行make ycm_support_libs`，就完成了整个的安装过程。 YouCompleteMe配置:&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; =&gt; YouCompleteMe 代码自动补全 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; Bundle &apos;Valloric/YouCompleteMe&apos; &quot; youcompleteme 默认tab s-tab 和自动补全冲突 &quot; let g:ycm_key_list_select_completion=[&apos;&lt;c-n&gt;&apos;] &quot; let g:ycm_key_list_select_completion = [&apos;&lt;Down&gt;&apos;] &quot; let g:ycm_key_list_previous_completion=[&apos;&lt;c-p&gt;&apos;] &quot; let g:ycm_key_list_previous_completion = [&apos;&lt;Up&gt;&apos;] let g:ycm_confirm_extra_conf=0 &quot; 关闭加载.ycm_extra_conf.py提示 let g:ycm_complete_in_comments = 1 &quot;在注释输入中也能补全 let g:ycm_complete_in_strings = 1 &quot;在字符串输入中也能补全 let g:ycm_collect_identifiers_from_tags_files=1 &quot; 开启 YCM 基于标签引擎 let g:ycm_collect_identifiers_from_comments_and_strings = 1 &quot;注释和字符串中的文字也会被收入补全 let g:ycm_seed_identifiers_with_syntax=1 &quot;语言关键字补全, 不过python关键字都很短，所以，需要的自己打开 let g:ycm_collect_identifiers_from_tags_files = 1 let g:ycm_min_num_of_chars_for_completion=2 &quot; 从第2个键入字符就开始罗列匹配项 &quot; 引入，可以补全系统，以及python的第三方包 针对新老版本YCM做了兼容 &quot; old version if !empty(glob(&quot;~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py&quot;)) let g:ycm_global_ycm_extra_conf = &quot;~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py&quot; endif &quot; new version if !empty(glob(&quot;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&quot;)) let g:ycm_global_ycm_extra_conf = &quot;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&quot; endif &quot;mapping nmap &lt;leader&gt;gd :YcmDiags&lt;CR&gt; nnoremap &lt;leader&gt;gl :YcmCompleter GoToDeclaration&lt;CR&gt; &quot; 跳转到申明处 nnoremap &lt;leader&gt;gf :YcmCompleter GoToDefinition&lt;CR&gt; &quot; 跳转到定义处 nnoremap &lt;leader&gt;gg :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt; &quot; 直接触发自动补全 let g:ycm_key_invoke_completion = &apos;&lt;C-Space&gt;&apos; &quot; 黑名单,不启用 let g:ycm_filetype_blacklist = { \ &apos;tagbar&apos; : 1, \ &apos;gitcommit&apos; : 1, \} 参考：YouCompleteMe配置&emsp;&emsp;&emsp;Vim智能补全插件YouCompleteMe安装]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>ycm</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于电影下载和广告屏蔽的那点事儿]]></title>
    <url>%2F2016%2F01%2F24%2F%E5%85%B3%E4%BA%8E%E7%94%B5%E5%BD%B1%E4%B8%8B%E8%BD%BD%E5%92%8C%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;我是处女座，有点轻微强迫症和完美主义，所以下电影什么的一般只下高清(蓝光720P起)，看到网上的各种广告也有点不爽，平常喜欢折腾，分享点自己的技巧吧。 &emsp;&emsp;先说下载电影，除了去电影院，网上看的电影一般都是下载720P的蓝光版，特别喜欢的会看蓝光原盘。那种电影刚上就能下载到的枪版更不会考虑，也不太推荐，画质堪忧。 &emsp;&emsp;在这里先简单的补充下网上高清电影的制作流程吧，一般是正规厂家发布了蓝光盘，然后一些高清论坛（SPARG、WiKi等）会进行无损发布（就是原盘，一半在30G50G），然后各大论坛会进行压制，压制成1080P(一半在10G15G)的或者720P(一般在5G左右)的，注意这时候电影都是没有双语字幕的，如果原盘是国内发行版的话里面会有一条国语字幕，但效果一般，在这之后各个字幕组再在此基础上进行进一步的压制、添加特效字幕和音轨等，完了再各自发布，字幕组做的字幕比原盘里封装的效果会好很多，每家字幕组也都会有自己的字幕风格，推荐看的时候使用这种字幕。 &emsp;&emsp;接下来说说关于下载方法的问题，可以用迅雷下载种子或者磁力链，如果速度一般的话可以使用百度云直接离线，完了再使用百度管家下载到本地，这种速度也会挺快的。以前百度云没对非会员限速，那会这种方法基本可以达到你网速所允许的最大下载速度，但现在百度对这限速，导致下载的速度多少会受到些影响，并且百度对于一些“你懂的”的资源封的很厉害，对于这种就只能用迅雷了。 &emsp;&emsp;给大家推荐几个我经常下电影的网站。 &emsp;&emsp;CMCT：目前网上对电影字幕特效处理的比较好的字幕组，会压制自己的1080P和720P版本，但这是邀请注册，并且没有自己的发布站点，下载他们家的电影必须去论坛下载。 &emsp;&emsp;圣城影视：圣城家园的发布页，这算大名鼎鼎的字幕组了，美剧和电影都做，其实cmct也是早期从圣城分出去的，但现在圣城的更新速度没有cmct的块，但好在质量有保证，字幕是蓝白风格的，看着也舒服。一般建议在上面两个网站下载720P的MKV了，如果你懒得去这些网站找，你可以直接百度电影名字+cmct或者cnscg，然后下载种子业可以。 &emsp;&emsp;高清MP4吧：更新速度很快，并且枪版、高清版都会发，下载的时候注意下载后缀里有BD的，这代表蓝光压制的，字幕特效做的不错，但很多都是copy别的字幕组然后处理一下特效，不是原创的，最大的优点就是更新速度快。 &emsp;&emsp;小调网、电影天堂： 这两网站算小水管的福利，电影大小一般都不超过2G，字幕特效不错，更新速度快，如果手机或者平板看的话可以从这里下载。 &emsp;&emsp;最后说下关于屏蔽广告的问题，现在浏览器打开网站的效果可以说惨不忍睹，各种广告各种弹窗，建议使用Adblock Plus进行屏蔽，360、火狐和chrome都有对应的插件，使用时可以把默认的拦截规则去除，然后订阅这里的规则：Adblock Plus官方规则Easylist China说明与反馈贴，只需要订阅轻量广告过滤规则方案的规则，不建议订阅Easylist，在chrome下订阅easylist的内存占用在100M以上，不订阅easylist规则的内存占用降到了28M左右。需要注意的是上面的方法无法屏蔽视频广告，如果想要屏蔽视频广告的话可以考虑使用Adsafe、adbyby之类的软件，对视频广告的过滤效果好，我现在使用的屏蔽方法是abp+adbyby。对于重度的谷歌搜索用户需要注意，只有abp能够屏蔽搜索里的推广链接。]]></content>
      <categories>
        <category>网络技巧</category>
      </categories>
      <tags>
        <tag>电影下载， 广告屏蔽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win7和Centos 7.2.1511的双系统安装]]></title>
    <url>%2F2016%2F01%2F16%2FWin7%E5%92%8CCentos-7-2-1511%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[本文针对使用U盘在Windows下安装Centos双系统，Centos版本号为7.2.1511。 1、安装、重装第一次安装的时候，在Windows的磁盘管理里压缩卷，压缩出的空白卷不分配盘符。如果需要重装，则需要把之前装centos的boot盘和centos在的盘删除，不分配盘符。如果分配盘符后在进入centos后的安装界面首页会出现无法识别硬盘的错误。如果重装的时候不小心误删了windows的其他盘符，请使用Diskgenuis软件进行搜索分区修复，注意此功能需要收费版本，免费版没有此功能。安装centos的U盘需要格式化为FAT32，而Centos安装包大于4G，注意在格式化U盘的时候需要在分配单元大小那选择8G，这样安装文件才能写道U盘里，否则无法写入U盘。 2、安装时配置在centos的安装界面里可以配置网络，根据自己的实际网络情况选择静态IP或自动获取，需要注意的是新版centos的静态IP在配置文件里的选项为none，而在之前的版本里为static。安装的时候记的选择图形界面，否则进入系统后只有命令行界面。 3、安装完成后需要修改centos的启动引导grub，否则重启后无法进入windows选项。此处提供几种修改方法。(1)可修改模板文件，/etc/grub.d/40_custom 在最后加入以下行 menuentry &apos;win7&apos;{ set root=(hd0,1) chainloader +1 } 然后运行grub2-mkconfig -o /boot/grub2/grub.cfg，此命令可在boot/grub2/grub.cfg里生成win7引导。注意chainloader和+间有空格。(2)在安装centos系统后，在线安装nfts-3g插件，这样就可以使用grub2-mkconfig -o /boot/grub2/grub.cfg，此命令会自动扫描系统，形成包含windows7的安装选项。 sudo yum install ntfs-3g sudo grub2-mkconfig -o /boot/grub2/grub.cfg more /boot/grub2/grub.cfg(3)直接在/boot/grub2/grub.cfg添加，缺点是升级后重新生成的grub文件会覆盖掉。第一种方法实际上就是间接写入grub.cfg。 参考：https://wiki.centos.org/zh/HowTos/Grub2 4、Win7双系统引导经过第三步后，重启电脑我们就可以在启动选项里选择win7，如果觉得这种启动方式不方便，我们还可以在win7里使用easybcd进行启动引导，推荐选择这样的双系统启动方式。参考：http://tieba.baidu.com/p/3191017719 5、常用软件 Firefox： centos的系统安装包里带的firefox都是旧版的，要想使用最新版的可以去火狐官网下载压缩包，直接解压就可以使用了，此时如果安装了flash重启浏览器后还是提示没有flash，需要把flash安装后的.so文件进行移动：sudo cp libflashplayer.so/usr/lib/mozilla/plugins Chrome：从官网下载rpm安装包后，在命令行下进行启动，启动命令： google-chrome --no-sandbox --user-data-dir或者在opt/google/chrome里面，以文本方式打开google-chrome，在 exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot;后面添加语句，注意之间的空格和两横杆。exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot; --no-sandbox --user-data-dir注意此处的chrome启动不使用沙盒，可能对安全性有所影响。 VLC：无法启动，查看系统日志发现是提示无法使用root启动。执行以下命令： sed -i &#39;s/geteuid/getppid/&#39; /usr/bin/vlc 搭建LAMP (1)安装Apache yum install httpd systemctl start httpd.service systemctl enable httpd.service (2)安装MySQL wget http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm rpm -ivh mysql-community-release-el7-5.noarch.rpm yum install mysql-community-server systemctl enable mysqld systemctl start mysqld mysql_secure_installation 参考:http://www.ahlinux.com/centos/23340.html (3)安装PHP yum install php yum -y install php-mysql php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-snmp php-soap curl curl-devel (4)安装phpMyAdmin yum install phpmyadmin systemctl restart httpd http://server_domain_or_IP/phpMyAdmin 参考：https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-phpmyadmin-with-apache-on-a-centos-7-server 参考：http://seisman.info/how-to-install-softwares-under-centos-7.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客搭建]]></title>
    <url>%2F2016%2F01%2F09%2Fhexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[这是我的第一篇github博客，鼓捣了好几天总算是搭建好了，总结下搭建整个环境的步骤吧。在真实搭建的时候参考了很多网上的资料，也走了很多弯路，在此按着正确的思路进行一下总结。 1、安装git、node.js、hexo这个属于前期工作，具体的可以参考hexo的官方教程。参考：Hexo官方中文文档&emsp;&emsp;&emsp;搭建hexo博客 2、hexo配置、优化我使用的主题是NexT，大家可以在hexo的主题列表里选择自己喜欢的。站点配置文件的设置可以参考hexo博客的配置使用，主题配置文件的可以参考你选择的主题的配置。参考：NexT使用文档&emsp;&emsp;&emsp;NexT主题配置参考 3、hexo部署相关在本地写完博客或者对博客进行修改后，每次都需要hexo g来重新生成文件，然后push到github端，在deploy的时候为了避免每次都需要重新输入github的账号和密码，可以添加SSH，此处SSH的作用相当于一把钥匙，当装着这把钥匙的电脑deploy的时候就无需再次输入github的账号密码。添加SSH的具体做法参考Generating an SSH key。 如果你在添加SSH后发现部署的时候仍然需要输入用户名密码，那么需要在你的站点配置文件(站点目录里的__config.yml)里进行修改， 在deploy里，把repo的地址从https://github.com/USERNAME/REPOSITORY.git改为git@github.com:USERNAME/OTHERREPOSITORY.git。原因是你之前使用的是https进行本地和远程github的连接，你使用SSH的时候自然也需要把链接改成SSH链接。当然你也可以选择使用github桌面客户端来进行上传，此时和本地和远程的链接使用的HTTPS，无需在在本地添加SSH密钥。参考：Which remote URL should I use?&emsp;&emsp;&emsp;重点参考里面的Cloning with HTTPS URLs和Cloning with SSH URLs。 4、hexo配置() 支持数学公式npm install hexo-math --save在站点_config.yml里添加 plugins: hexo-math 参考资料：(1)hexo你的博客(2)怎样使用Markdown(3)Markdown: Basics （快速入门）(4)Markdown 语法说明 (简体中文版)(5)多机更新 Hexo 博客]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
